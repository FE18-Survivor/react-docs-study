# Reacting to Input with State

React는 어떤 상태의 UI를 보여줄지 선언적인 방식으로 조작한다. 어떤 상태의 UI를 보여줄지 선언하고 상태 변화에 따라 업데이트한다.

## imperative vs declarative

### imperative

명렁적으로 구현한 코드를 살펴보자.

```jsx
async function handleFormSubmit(e) {
  e.preventDefault();
  disable(textarea);
  disable(button);
  show(loadingMessage);
  hide(errorMessage);
  try {
    await submitForm(textarea.value);
    show(successMessage);
    hide(form);
  } catch (err) {
    show(errorMessage);
    errorMessage.textContent = err.message;
  } finally {
    hide(loadingMessage);
    enable(textarea);
    enable(button);
  }
}
```

위 코드는 명령적으로 구현한 코드이다. 함수들을 직접 호출하면서 DOM을 직접 조작해야 하고, 규모가 커지면 관리하기 힘들고, 예상치 못한 버그가 일어날 수 있다.

### declarative

선언적 UI는 무엇일까? 택시를 예로 들었을 때, 최종 목적지만 얘기하고 경로까지 말하지 않는 상황을 예시로 든다. **목적지**만 얘기하고 세부적인 부분 까지는 기사에게 맡기는 것이다.

React는 **어떤 상태에 어떤 UI를 보여줄지만 선언** 하고, 상태 변화에 따른 실제 업데이트는 React에게 맡기라고 한다.

## 선언적 UI 생각하기

### 1. Identify your component’s different visual states

컴포넌트의 다양한 시각적 상태를 식별하기.

먼저 사용자가 볼 수 있는 UI의 상태들을 모두 상상해보라고 한다.

```jsx
export default function Form({ status = "empty" }) {
  if (status === "success") {
    return <h1>That's right!</h1>;
  }
  return (
    <>
      <h2>City quiz</h2>
      <p>
        In which city is there a billboard that turns air into drinkable water?
      </p>
      <form>
        <textarea />
        <br />
        <button>Submit</button>
      </form>
    </>
  );
}
```

예시 코드와 같이 구현 전에 **Empty/Typing/Submitting/Success/Error** 같은 시각적 상태를 먼저 나열하고 목업을 만든다. 그런 다음 status prop으로 이 상태를 제어하는 목업 컴포넌트를 보여주고, status 값을 바꿔가며 각 상태의 화면을 빠르게 시도해보라고 한다.

```jsx
export default function Form({
  // Try 'submitting', 'error', 'success':
  status = "empty",
}) {
  if (status === "success") {
    return <h1>That's right!</h1>;
  }
  return (
    <>
      <h2>City quiz</h2>
      <p>
        In which city is there a billboard that turns air into drinkable water?
      </p>
      <form>
        <textarea disabled={status === "submitting"} />
        <br />
        <button disabled={status === "empty" || status === "submitting"}>
          Submit
        </button>
        {status === "error" && (
          <p className="Error">Good guess but a wrong answer. Try again!</p>
        )}
      </form>
    </>
  );
}
```

### 2. Determine what triggers those state changes

state 변화를 trigger 하는 것이 무엇인지 알아내기.

input을 예시로 state를 변경하는 입력은 **human**(텍스트를 변경하거나, 제출 버튼을 클릭하는)과 **computer**(네트워크 응답에 따른 상태 변화)로 크게 나눌 수 있다.

이런 흐름을 시각화하는 연습을 하고, 순서도를 그리면 흐름을 파악하기 쉽다.

### 3. Represent the state in memory with useState

useState로 메모리의 state 표현하기.

상태는 개수가 많은 것보다 가능한 적게, 복잡하지 않게 가지는 것이 좋다.

처음부터 구조를 잘 짜면 좋겠지만, 중요도가 높은, 필수적인 state부터 선언하고, 점점 늘려나가며 여러 시행착오를 겪어볼 필요가 있다.

```jsx
// 필수적인 것부터
const [answer, setAnswer] = useState("");
const [error, setError] = useState(null);

// 상태들 나열해보기
const [isEmpty, setIsEmpty] = useState(true);
const [isTyping, setIsTyping] = useState(false);
const [isSubmitting, setIsSubmitting] = useState(false);
const [isSuccess, setIsSuccess] = useState(false);
const [isError, setIsError] = useState(false);
```

### 4. Remove any non-essential state variables

3번 과정을 거쳐보고, 중복되거나, 모순이 있는, 불필요한 state 들을 제거해보는 과정이다.

예를 들어, `isTyping` 과 `isSubmitting` 은 서로 반대의 성질을 가지고 있어 모순이 있는 state이다.

또, isEmpty 와 isTyping 은 동시에 true일 수 없다. isError와 isSuccess도 boolean으로 체크할 수 있다.

이러한 시행착오를 거치면 아래처럼 불필요한 state를 줄일 수 있다.

```jsx
const [answer, setAnswer] = useState("");
const [error, setError] = useState(null);
const [status, setStatus] = useState("typing"); // 'typing', 'submitting', or 'success'
```

> `status==="success"` 일 때 error가 있는 경우는?
>
> [Reduce로 분리](https://react.dev/learn/extracting-state-logic-into-a-reducer)

### 5. Connect the event handlers to set state

이벤트 핸들러를 연결하기.

```jsx
import { useState } from "react";

export default function Form() {
  const [answer, setAnswer] = useState("");
  const [error, setError] = useState(null);
  const [status, setStatus] = useState("typing");

  if (status === "success") {
    return <h1>That's right!</h1>;
  }

  async function handleSubmit(e) {
    e.preventDefault();
    setStatus("submitting");
    try {
      await submitForm(answer);
      setStatus("success");
    } catch (err) {
      setStatus("typing");
      setError(err);
    }
  }

  function handleTextareaChange(e) {
    setAnswer(e.target.value);
  }

  return (
    <>
      <h2>City quiz</h2>
      <p>
        In which city is there a billboard that turns air into drinkable water?
      </p>
      <form onSubmit={handleSubmit}>
        <textarea
          value={answer}
          onChange={handleTextareaChange}
          disabled={status === "submitting"}
        />
        <br />
        <button disabled={answer.length === 0 || status === "submitting"}>
          Submit
        </button>
        {error !== null && <p className="Error">{error.message}</p>}
      </form>
    </>
  );
}

function submitForm(answer) {
  // Pretend it's hitting the network.
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      let shouldError = answer.toLowerCase() !== "lima";
      if (shouldError) {
        reject(new Error("Good guess but a wrong answer. Try again!"));
      } else {
        resolve();
      }
    }, 1500);
  });
}
```

모든 상호작용을 **상태 변경**으로 표현하고, 렌더링은 현재 상태를 기반으로 선언적으로 작성한다. 이렇게 하면 새로운 시각적 상태를 추가해도 기존 로직을 덜 깨뜨리게 되고, 상태별 UI와 로직을 조금 더 독립적으로 관리할 수 있다.​

# Choosing the State Structure

state 구조를 어떻게 짜야 유지보수하기 쉬울까?

## state를 구조화하는 원칙

### Group related state

관련있는 state들은 묶어서 관리하기.

```jsx
// 1
const [x, setX] = useState(0);
const [y, setY] = useState(0);

// 2
const [position, setPosition] = useState({ x: 0, y: 0 });
```

x,y를 따로 관리할 수도 있고, 묶어서 관리할 수도 있다. x,y가 좌표에서 사용된다는 가정 하에 둘은 같이 업데이트 되므로, 2번과 같이 묶어서 관리하는 것이 실수를 막는 데에 좋다.

또, 계속해서 추가하는 상황이 있을 때는 state가 몇 개가 필요할 지 예상하기 어려우니 묶어서 관리하는 것이 좋다.

### Avoid contradictions in state

state 모순 피하기.

```jsx
const [text, setText] = useState("");
const [isSending, setIsSending] = useState(false);
const [isSent, setIsSent] = useState(false);
```

isSending 과 isSent 는 논리상 반대의 성질을 가진다. 하지만 이렇게 두 가지 모두 state를 선언하면 둘이 같은 값을 가지게 되는 상황을 초래할 수도 있다.

```jsx
const [text, setText] = useState("");
const [status, setStatus] = useState("typing");

async function handleSubmit(e) {
  e.preventDefault();
  setStatus("sending");
  await sendMessage(text);
  setStatus("sent");
}
```

둘을 하나의 상태로 관리하고, 상태의 값을 이용하는 방식으로 수정하여 렌더링 때 상태를 계산하는 것이 더 안전하다.

### Avoid redundant state

렌더링 중에 기존 props나 state로부터 계산할 수 있는 값은 만들지 말기.

```jsx
import { useState } from "react";

export default function Form() {
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");
  const [fullName, setFullName] = useState("");

  function handleFirstNameChange(e) {
    setFirstName(e.target.value);
    setFullName(e.target.value + " " + lastName);
  }

  function handleLastNameChange(e) {
    setLastName(e.target.value);
    setFullName(firstName + " " + e.target.value);
  }

  return (
    <>
      <h2>Let’s check you in</h2>
      <label>
        First name: <input value={firstName} onChange={handleFirstNameChange} />
      </label>
      <label>
        Last name: <input value={lastName} onChange={handleLastNameChange} />
      </label>
      <p>
        Your ticket will be issued to: <b>{fullName}</b>
      </p>
    </>
  );
}
```

FullName은 firstName과 lastName으로 렌더링 시 계산할 수 있기 때문에 불필요하여 제거하는 것이 좋다.

> props를 state에 복제하지 마라.
>
> props가 바뀌어도 state는 동기화 되지 않는다. 그래서 초기값을 보여줘야 할 때 사용할 수도 있는데, 이는 prop의 이름으로 `initial + ~ `을 붙여서 동기화 되지 않음을 꼭 보여줘라.
> [week02/상인 - 순수성 및 구조 잘짜기](https://github.com/FE18-Survivor/react-docs-study/blob/main/week-02/%EC%83%81%EC%9D%B8.md#%EB%82%98%EB%8A%94-%EC%9A%94%EC%A6%98-useeffect%EB%A1%9C-ai-%EC%BD%94%EB%93%9C%EC%9D%B8%EC%A7%80-%EA%B5%AC%EB%B6%84%EC%9D%84-%ED%95%9C%EB%8B%A4)

### Avoid duplication in state

중복 state 피하기.

```jsx
import { useState } from "react";

const initialItems = [
  { title: "pretzels", id: 0 },
  { title: "crispy seaweed", id: 1 },
  { title: "granola bar", id: 2 },
];

export default function Menu() {
  const [items, setItems] = useState(initialItems);
  const [selectedItem, setSelectedItem] = useState(items[0]);

  function handleItemChange(id, e) {
    setItems(
      items.map((item) => {
        if (item.id === id) {
          return {
            ...item,
            title: e.target.value,
          };
        } else {
          return item;
        }
      })
    );
  }

  return (
    <>
      <h2>What's your travel snack?</h2>
      <ul>
        {items.map((item, index) => (
          <li key={item.id}>
            <input
              value={item.title}
              onChange={(e) => {
                handleItemChange(item.id, e);
              }}
            />
            <button
              onClick={() => {
                setSelectedItem(item);
              }}
            >
              Choose
            </button>
          </li>
        ))}
      </ul>
      <p>You picked {selectedItem.title}.</p>
    </>
  );
}
```

항목 제목을 수정하도록 폼을 바꾸면 리스트는 업데이트되지만 `selectedItem.title`은 그대로인 버그가 생긴다.

같은 데이터를 여러 state 변수에 선언하면 동기화 문제를 맞을 위험이 크다.

```jsx
const [items, setItems] = useState(initialItems);
const [selectedId, setSelectedId] = useState(0);

const selectedItem = items.find((item) => item.id === selectedId);
```

id를 이용해서 표현하고, 렌더링 때 selectedItem을 조회하여 결정하는 것이 좋다.

### Avoid deeply nested state

깊은 중첩 state는 피하기.

```jsx
export const initialTravelPlan = {
  id: 0,
  title: '(Root)',
  childPlaces: [{
    id: 1,
    title: 'Earth',
    childPlaces: [{
      id: 2,
      title: 'Africa',
      childPlaces: [{
        ...

  const [plan, setPlan] = useState(initialTravelPlan);
```

이 state를 업데이트 한다고 상상해보면 끔찍하다. 객체를 업데이트 하기 위해서 복사를 해야할 것 같은데, 내부 객체까지 깊이 복사를 해야하기 때문이다.

이럴 때는 flat한 구조로 바꾸는 방법이 좋다. -> 데이터 정규화

```jsx
export const initialTravelPlan = {
  0: {
    id: 0,
    title: '(Root)',
    childIds: [1, 42, 46],
  },
  1: {
    id: 1,
    title: 'Earth',
    childIds: [2, 10, 19, 26, 34]
  },
  2: {
    id: 2,
    title: 'Africa',
    childIds: [3, 4, 5, 6 , 7, 8, 9]
  },
  ...
```
