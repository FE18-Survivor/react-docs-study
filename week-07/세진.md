# Week07
## Referencing Values with Refs
> ref는 information은 저장(기억)하지만, components는 렌더링 하고싶지 않을 때 사용할 수 있습니다.
### How to add a ref to components
```javascript
import { useRef } from 'react';

const ref = useRef(0);
```

useRef를 import하고 해당 hook을 사용한 ref변수를 만듭니다. 초기 값을 정할 수 있으며 해당 값은 `ref.current`로 접근할 수 있습니다.

[스톱워치 예제](https://react.dev/learn/referencing-values-with-refs#example-building-a-stopwatch)

`setInterval()`과 `clearInterval`을 ref에 저장하여 스톱워치의 stop을 눌렀을때의 시간과 화면에서 보여지는 시간(흐르는 시간) 사이의 간격을 없애고 stop누른 시간을 화면에 보여지게 합니다.

### state와 ref의 차이
|refs|state|
|--|--|
|`useRef(initialValue)` returns `{ current: initialValue }`|`useState(initialValue)` returns `( [value, setValue])`(변수와 setter 함수) |
|re-render의 trigger가 되지 않음 | re-render가 됨|
|Mutable: `current`의 값을 **변경**할수있음|Immutable: 변경하려면 setting 함수를 사용해 변경해야함(즉, 값 자체를 변경할수는 없음)|
|rendering중에 읽거나 쓸 수 없음 | rendering중에 읽을 수 있음. 해당 형태는 snapshot 형태임|

- `ref.current`의 값은 렌더링중에 읽을 수 없기 때문에 화면에 표시되지 않음

### useRef 동작원리
`useRef`는 `useState`위에서 동작합니다. 
```javascript
// Inside of React
function useRef(initialValue) {
  const [ref, unused] = useState({ current: initialValue });
  return ref;
}
```

첫 rendering때, useRef는 `{ current: initialValue }`를 반환하고 이는 React에 저장됩니다. 렌더링이 끝날때마다 같은 값이 반환됩니다.

### useRef를 사용하는 경우
- Storing timeout IDs
- Storing and manipulating DOM elements.
- Storing other objects that aren’t necessary to calculate the JSX.

주로 브라우저 API 같이 컴포넌트 외부의 API와 통신할때 사용하게 됩니다.

### ref 사용의 모범사례
- ref를 탈출구 처럼 사용하기: 너무 많은 로직이 ref에 의존하면 로직을 다시 생각해야 합니다.
- rendering중엔 ref를 읽거나 쓰지 않기: rendering중에 필요한 데이터라면 ref가 아니라 state를 사용해야합니다.



## Manipulating the DOM with Refs
> React는 자동으로 render output에 맞춰 DOM을 업데이트 하기에 대부분 컴포넌트에서 조작할 필요가 없지만, focusing, scroll등 DOM 조작이 필요할때엔 ref를 사용할 수 있습니다.

### node에 ref 추가하기
```javascript
import { useRef } from 'react';

const myRef = useRef(null);

<div ref={myRef}>
```

`<div>`에 DOM node가 만들어지면 해당 node에 myRef.current가 존재하게 됩니다. 해당 값을 통해 node에 접근할 수 있게 됩니다.


e.g. `myRef.current.scrollIntoView();`

### 다른 컴포넌트의 DOM node에 접근하기
```javascript
import { useRef } from 'react';

function MyInput({ ref }) {
  return <input ref={ref} />;
}

function MyForm() {
  const inputRef = useRef(null);
  return <MyInput ref={inputRef} />
}
```

props처럼 부모컴포넌트가 자식컴포넌트에게 전달할 수 있습니다.

```javascript
...
  useImperativeHandle(ref, () => ({
    focus() {
      realInputRef.current.focus();
    },
  }));
...
```

자식컴포넌트에 해당 함수를 사용하게 되면 오로지 focus만 사용할 수 있게 됩니다.


### When React attaches the refs 
React의 업데이트는 두가지 타이밍에 진행됩니다.
- 렌더링 될때
- 커밋 될때

React는 커밋 될때 ref를 설정합니다. DOM이 업데이트 되기 전에 ref를 null로 가져오고 DOM이 업데이트 된 직후 해당 node들로 ref를 설정합니다.

주로 **event handler**에서 ref에 접근하게 됩니다.

#### [Flushing state updates synchronously with flushSync](https://react.dev/learn/manipulating-the-dom-with-refs#flushing-state-updates-synchronously-with-flush-sync)

```javascript
import { useState, useRef } from 'react';

export default function TodoList() {
  const listRef = useRef(null);
  const [text, setText] = useState('');
  const [todos, setTodos] = useState(
    initialTodos
  );

  function handleAdd() {
    const newTodo = { id: nextId++, text: text };
    setText('');
    setTodos([ ...todos, newTodo]);
    listRef.current.lastChild.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest'
    });
  }

  return (
    <>
      <button onClick={handleAdd}>
        Add
      </button>
      <input
        value={text}
        onChange={e => setText(e.target.value)}
      />
      <ul ref={listRef}>
        {todos.map(todo => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </>
  );
}

let nextId = 0;
let initialTodos = [];
for (let i = 0; i < 20; i++) {
  initialTodos.push({
    id: nextId++,
    text: 'Todo #' + (i + 1)
  });
}

```

위와 같은 코드가 있을때 실제로 todo가 추가되면 scroll은 가장 신규 todo가 아닌, 그 위의 todo로 이동하게 됩니다. 이는 `todos`가 즉시 업데이트 되지 않아서 ref의 scroll 이벤트는 신규 todo가 아닌 그 위의 todo를 가장 마지막 `<li>`로 기억하고 있기 때문입니다.

이를 해결하기 위해 `flushSync`를 사용할 수 있습니다.

```javascript
...
flushSync(() => {
  setTodos([ ...todos, newTodo]);
});
listRef.current.lastChild.scrollIntoView();
```

### Best practices for DOM manipulation with refs
- focusing, scroll, calling browser API 상황에서만 사용하는것이 좋습니다.
- React가 관리하는 DOM node를 직접 수정하지 않는것이 좋습니다.
- 만약 React가 업데이트 하지 않는 node라면 수정해도 좋습니다.
