# Week07
## Referencing Values with Refs
> ref는 information은 저장(기억)하지만, components는 렌더링 하고싶지 않을 때 사용할 수 있습니다.
### How to add a ref to components
```javascript
import { useRef } from 'react';

const ref = useRef(0);
```

useRef를 import하고 해당 hook을 사용한 ref변수를 만듭니다. 초기 값을 정할 수 있으며 해당 값은 `ref.current`로 접근할 수 있습니다.

[스톱워치 예제](https://react.dev/learn/referencing-values-with-refs#example-building-a-stopwatch)

`setInterval()`과 `clearInterval`을 ref에 저장하여 스톱워치의 stop을 눌렀을때의 시간과 화면에서 보여지는 시간(흐르는 시간) 사이의 간격을 없애고 stop누른 시간을 화면에 보여지게 합니다.

### state와 ref의 차이
|refs|state|
|--|--|
|`useRef(initialValue)` returns `{ current: initialValue }`|`useState(initialValue)` returns `( [value, setValue])`(변수와 setter 함수) |
|re-render의 trigger가 되지 않음 | re-render가 됨|
|Mutable: `current`의 값을 **변경**할수있음|Immutable: 변경하려면 setting 함수를 사용해 변경해야함(즉, 값 자체를 변경할수는 없음)|
|rendering중에 읽거나 쓸 수 없음 | rendering중에 읽을 수 있음. 해당 형태는 snapshot 형태임|

- `ref.current`의 값은 렌더링중에 읽을 수 없기 때문에 화면에 표시되지 않음

### useRef 동작원리
`useRef`는 `useState`위에서 동작합니다. 
```javascript
// Inside of React
function useRef(initialValue) {
  const [ref, unused] = useState({ current: initialValue });
  return ref;
}
```

첫 rendering때, useRef는 `{ current: initialValue }`를 반환하고 이는 React에 저장됩니다. 렌더링이 끝날때마다 같은 값이 반환됩니다.

### useRef를 사용하는 경우
- Storing timeout IDs
- Storing and manipulating DOM elements.
- Storing other objects that aren’t necessary to calculate the JSX.

주로 브라우저 API 같이 컴포넌트 외부의 API와 통신할때 사용하게 됩니다.

### ref 사용의 모범사례
- ref를 탈출구 처럼 사용하기: 너무 많은 로직이 ref에 의존하면 로직을 다시 생각해야 합니다.
- rendering중엔 ref를 읽거나 쓰지 않기: rendering중에 필요한 데이터라면 ref가 아니라 state를 사용해야합니다.



## Manipulating the DOM with Refs
> React는 자동으로 render output에 맞춰 DOM을 업데이트 하기에 대부분 컴포넌트에서 조작할 필요가 없지만, focusing, scroll등 DOM 조작이 필요할때엔 ref를 사용할 수 있습니다.

### node에 ref 추가하기
```javascript
import { useRef } from 'react';

const myRef = useRef(null);

<div ref={myRef}>
```

`<div>`에 DOM node가 만들어지면 해당 node에 myRef.current가 존재하게 됩니다. 해당 값을 통해 node에 접근할 수 있게 됩니다.


e.g. `myRef.current.scrollIntoView();`

### 다른 컴포넌트의 DOM node에 접근하기
```javascript
import { useRef } from 'react';

function MyInput({ ref }) {
  return <input ref={ref} />;
}

function MyForm() {
  const inputRef = useRef(null);
  return <MyInput ref={inputRef} />
}
```

props처럼 부모컴포넌트가 자식컴포넌트에게 전달할 수 있습니다.

```javascript
...
  useImperativeHandle(ref, () => ({
    focus() {
      realInputRef.current.focus();
    },
  }));
...
```

자식컴포넌트에 해당 함수를 사용하게 되면 오로지 focus만 사용할 수 있게 됩니다.


### When React attaches the refs 
React의 업데이트는 두가지 타이밍에 진행됩니다.
- 렌더링 될때
- 커밋 될때

React는 커밋 될때 ref를 설정합니다. DOM이 업데이트 되기 전에 ref를 null로 가져오고 DOM이 업데이트 된 직후 해당 node들로 ref를 설정합니다.

주로 **event handler**에서 ref에 접근하게 됩니다.

#### [Flushing state updates synchronously with flushSync](https://react.dev/learn/manipulating-the-dom-with-refs#flushing-state-updates-synchronously-with-flush-sync)

```javascript
import { useState, useRef } from 'react';

export default function TodoList() {
  const listRef = useRef(null);
  const [text, setText] = useState('');
  const [todos, setTodos] = useState(
    initialTodos
  );

  function handleAdd() {
    const newTodo = { id: nextId++, text: text };
    setText('');
    setTodos([ ...todos, newTodo]);
    listRef.current.lastChild.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest'
    });
  }

  return (
    <>
      <button onClick={handleAdd}>
        Add
      </button>
      <input
        value={text}
        onChange={e => setText(e.target.value)}
      />
      <ul ref={listRef}>
        {todos.map(todo => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </>
  );
}

let nextId = 0;
let initialTodos = [];
for (let i = 0; i < 20; i++) {
  initialTodos.push({
    id: nextId++,
    text: 'Todo #' + (i + 1)
  });
}

```

위와 같은 코드가 있을때 실제로 todo가 추가되면 scroll은 가장 신규 todo가 아닌, 그 위의 todo로 이동하게 됩니다. 이는 `todos`가 즉시 업데이트 되지 않아서 ref의 scroll 이벤트는 신규 todo가 아닌 그 위의 todo를 가장 마지막 `<li>`로 기억하고 있기 때문입니다.

이를 해결하기 위해 `flushSync`를 사용할 수 있습니다.

```javascript
...
flushSync(() => {
  setTodos([ ...todos, newTodo]);
});
listRef.current.lastChild.scrollIntoView();
```

### Best practices for DOM manipulation with refs
- focusing, scroll, calling browser API 상황에서만 사용하는것이 좋습니다.
- React가 관리하는 DOM node를 직접 수정하지 않는것이 좋습니다.
- 만약 React가 업데이트 하지 않는 node라면 수정해도 좋습니다.

<br />

## Synchronizing with Effects
> `Effect`를 통해 리액트 외부의 시스템과 컴포넌트를 synchronize 할수 있게 합니다.

### 이펙트의 정의와 이벤트와의 차이점

- 렌더링 코드 : 컴포넌트 상위레벨에 있으며 프롭이나 스테이트를 받거나 변형하거나 JSX를 반환하는 코드. 순수해야함.
- 이벤트 핸들러 : 컴포넌트 내부에 중첩되어있는 함수이며 무언가 계산하는것이 아니라 행동을 함. 이벤트 핸들러가 사이드 이펙트를 포함함.

이펙트는 리액트 코드에서 벗어나 외부시스템과 연결되는 것으로, 렌더링에 의해 발생하는 side effect를 지정할 수 있게 합니다. 이펙트는 스크린이 업데이트 되고 커밋된 후에 동작합니다.
이벤트는 사용자의 행동(click 등)이 있어야만 동작하기 때문에 초기설정을 위한 side effect는 Effects를 활용해야 합니다.

### Effect 사용법

1. Effect를 정의합니다. 우선 commit 이후에 한번 동작하게 됩니다.

```javascript
import { useEffect } from 'react';

function MyComponent() {
  useEffect(() => {
    // Code here will run after *every* render
  });
  return <div />;
}
```

2. Effect dependencies를 특정합니다. dependencies를 통해 Effects의 re-run을 컨트롤할 수 있습니다.기본적으로 Effects는 모든 rendering 과정에 동작합니다. 이를 컨트롤하기 위해 디펜던시를 추가합니다.

  ```javascript
  useEffect(() => {
    // This runs after every render
  });

  useEffect(() => {
    // This runs only on mount (when the component appears)
  }, []);

  useEffect(() => {
    // This runs on mount *and also* if either a or b have changed since the last render
  }, [a, b]);
  ```

3. 필요시, cleanup 코드를 추가합니다. 
```javascript
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

export default function ChatRoom() {
  useEffect(() => {
  const connection = createConnection();
  connection.connect();
  return () => connection.disconnect();
}, []);

return <h1>Welcome to the chat!</h1>;
}
```

이펙트는 페이지가 mount 되면 다시 실행(run)하는데 connecting은 유지가 되어있게 됩니다. 이미 connecting되어있는데 또 connect를 하게 되는것이니 이를 방지 하기 위해서 cleanup code를 추가할 수 있습니다.

### development 환경에서 Effects를 다루는 법
리액트는 개발환경에서 버그를 찾기위해 컴포넌트를 remount합니다. "어떻게 Effects를 한번만 실행할지"가 아니라 "리마운팅 이후에 어떻게 동작하게 할지"를 고민해야 합니다. 이를 위해 cleanup 함수를 사용할 수 있습니다. 클린업 함수로 Effects가 무엇을 하든 멈추거나 되돌릴 수 있습니다.

- [Controlling non-React widgets](https://react.dev/learn/synchronizing-with-effects#controlling-non-react-widgets)
- [Subscribing to events](https://react.dev/learn/synchronizing-with-effects#subscribing-to-events)
- [Triggering animations](https://react.dev/learn/synchronizing-with-effects#triggering-animations)
- [Fetching data](https://react.dev/learn/synchronizing-with-effects#fetching-data)
- [Sending analytics](https://react.dev/learn/synchronizing-with-effects#sending-analytics)

