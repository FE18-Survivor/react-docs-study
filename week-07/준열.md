<a href="https://react.dev/learn/referencing-values-with-refs"><h1>Referencing Values with Refs</h1></a>

- 컴포넌트가 렌더링에는 필요 없지만 내부적으로 사용해야 하는 값을 저장해야 할 때
- 그리고 그 값이 바뀌어도 리렌더링을 일으키고 싶지 않을 때 ref를 사용한다.

## Ref 사용방법

```javascript
import { useRef } from "react";

const ref = useRef(0);
```

- **useRef** Hook을 React에서 import한 뒤, 컴포넌트 안에서 **useRef(초기값)** 형태로 호출해서 **ref 객체** 를 만든다.
- **useRef(0)** 처럼 사용하면 **{ current: 0 }** 형태의 객체가 반환되고, **current** 프로퍼티에 초기값이 들어 있다.  

## ref.current 특징

- ref가 갖고있는 current 값은 읽고 쓸 수 있도록  intentionally mutable 하게 설계되어있다.
- 또한, ref는 React가 추적하지 않는다.

## 예시코드를 통한 state와 ref 사용방식

- 예시코드를 통해 state와 ref의 사용방식을 알아보자.

- 사용자가 버튼을 클릭했을 때 시작과 정지를 하는 스톱워치를 만든다고 생각해보자.

- 그렇다면, 첫 번째로 사용자가 Start 버튼을 클릭했을 때, 시간이 얼마나 지났는지 보여주게 하려면 **Start 버튼을 누른 시각** 과 **현재 시각** 을 알고 있어야한다.

- 이러한 정보들은 화면에 렌더링되어야하는 요소이므로 아래와 같이 state로 관리하게 된다.

```javascript
const [startTime, setStartTime] = useState(null); // Start 버튼을 누른 시각
const [now, setNow] = useState(null); // 현재 시각
``` 

- 그리고 Start 버튼을 클릭했을 때 이 state들을 세팅하고, 일정주기로 now를 업데이트하는 handler를 만든다.

```javascript
function handleStart() {
  // Start를 누른 시각과 현재 시각을 모두 지금 시각으로 설정
  setStartTime(Date.now());
  setNow(Date.now());

  // 이후 10ms마다 now를 현재 시각으로 업데이트
  setInterval(() => {
    setNow(Date.now());
  }, 10);
}
```

- 이 다음 Stop 버튼을 클릭했을 때 스톱워치를 멈추게 하려면 setInterval로 만든 타이머를 clearInterval로 취소해야한다.

- clearInterval를 호출하려면 setInterval이 반환하는 interval ID가 필요하고 동시에 저장을 해야한다.

- interval ID 값은 렌더링에 필요하지않고 오직 handler에서만 필요하기 때문에 여기서 ref가 필요하다.

```javascript
import { useRef , useState } from "react";

...
const intervalRef = useRef(null); // setInterval이 반환한 interval ID를 저장
```

이후 handler를 아래와 같이 수정할 수 있다.

```javascript
function handleStart() {
  setStartTime(Date.now());
  setNow(Date.now());

  // 기존 interval이 있다면 먼저 정리
  clearInterval(intervalRef.current);

  // 새 interval을 만들고, 반환된 ID를 ref에 저장
  intervalRef.current = setInterval(() => {
    setNow(Date.now());
  }, 10);
}

function handleStop() {
  // ref에 저장해 둔 ID로 interval 정지
  clearInterval(intervalRef.current);
}
```

## state와 ref의 차이점

| 구분          | ref                                                           | state                                                             |
| ----------- | ------------------------------------------------------------- | ----------------------------------------------------------------- |
| 선언          | useRef(initialValue)는 { current: initialValue } 형태의 객체를 반환한다. | useState(initialValue)는 현재 값과 setter 함수인 [value, setValue]를 반환한다. |
| 값 변경 시 리렌더링 | current를 바꿔도 리렌더링이 일어나지 않는다.                                  | 값을 업데이트하면 컴포넌트가 리렌더링된다.                                           |
| 가변성         | 가변(mutable)이라 렌더링 과정 밖에서 current 값을 마음대로 읽고 쓸 수 있다.           | 불변(immutable) 취급이라 반드시 setter 함수를 통해서만 변경을 요청한다.                  |
| 읽기 시점       | 렌더링 중에는 ref.current를 읽거나 쓰지 않는 것이 권장된다.                       | 언제든 읽을 수 있지만, 각 렌더는 그 시점의 state 스냅샷을 보는 식으로 동작한다.                 |


## useRef의 내부동작 방식

- React 내부에서 useRef는 아래와 같이 구현되어 있다고 생각할 수 있다.

```javascript
function useRef(initialValue) {
  const [ref, unused] = useState({ current: initialValue });
  return ref;
}
````

- 첫 렌더 때 **{ current: initialValue }** 객체를 한 번 만들고, state에 저장한 뒤 이후 렌더에서도 동일한 객체를 그대로 반환한다.

- state 업데이트 함수는 사용하지 않고, 컴포넌트 쪽에서 **ref.current = ...** 처럼 직접 필드를 바꿔 리렌더링 없이 값만 바뀌는 저장소 역할을 한다.


## 언제 refs를 사용해야할까?

- 값을 저장해야할 때, 그 값이 바뀌어도 렌더링 로직이나 화면에 영향을 주지 않을때 ref를 사용한다.

## refs를 잘 사용하는 방법 

- ref는 escape hatch처럼 사용해야한다.
  - 외부 시스템이나 브라우저 API(DOM, 타이머 등)와 상호작용할 때만 최소한으로 ref를 쓰고, 애플리케이션의 주요 로직과 데이터 흐름은 state/props에 두는 것이 좋다.
  
- 렌더링 중에는 ref.current를 읽거나 쓰지 않는다.
  - 렌더링에 필요한 정보라면 ref가 아니라 state를 사용해야 한다. ref.current가 언제 바뀌는지 React는 모르기 때문에, 렌더 과정에서 이 값에 의존하면 컴포넌트 동작을 예측하기 어려워진다.
  
- state에 적용되는 제약은 ref에는 없다.
  - state는 렌더마다 스냅샷처럼 동작하고, 업데이트도 비동기 큐에 쌓이지만, ref는 그냥 JS 객체라 ref.current = 5; console.log(ref.current); 하면 즉시 5가 찍힌다. 또한 ref는 “불변성 유지”를 신경 쓸 필요가 없다. 단, 그 객체가 렌더링(화면) 계산에 사용되지 않을 때에만 마음대로 mutate해도 된다.

## ref와 DOM

- ref는 어떤 값이든 가리킬 수 있지만, 가장 흔한 사용처는 **DOM 요소** 를 가리키는 것이다.

- JSX에서 `<div ref={myRef}>` 처럼 **ref** 속성에 ref를 넘기면, React가 해당 DOM 요소를 찾아서 **myRef.current** 에 넣어 준다.

- 나중에 그 요소가 DOM에서 제거되면, React가 myRef.current를 자동으로 null로 바꿔 준다.

