<a href="https://react.dev/learn/referencing-values-with-refs"><h1>Referencing Values with Refs</h1></a>

- 컴포넌트가 렌더링에는 필요 없지만 내부적으로 사용해야 하는 값을 저장해야 할 때
- 그리고 그 값이 바뀌어도 리렌더링을 일으키고 싶지 않을 때 ref를 사용한다.

## Ref 사용방법

```javascript
import { useRef } from "react";

const ref = useRef(0);
```

- **useRef** Hook을 React에서 import한 뒤, 컴포넌트 안에서 **useRef(초기값)** 형태로 호출해서 **ref 객체** 를 만든다.
- **useRef(0)** 처럼 사용하면 **{ current: 0 }** 형태의 객체가 반환되고, **current** 프로퍼티에 초기값이 들어 있다.  

## ref.current 특징

- ref가 갖고있는 current 값은 읽고 쓸 수 있도록  intentionally mutable 하게 설계되어있다.
- 또한, ref는 React가 추적하지 않는다.

## 예시코드를 통한 state와 ref 사용방식

- 예시코드를 통해 state와 ref의 사용방식을 알아보자.

- 사용자가 버튼을 클릭했을 때 시작과 정지를 하는 스톱워치를 만든다고 생각해보자.

- 그렇다면, 첫 번째로 사용자가 Start 버튼을 클릭했을 때, 시간이 얼마나 지났는지 보여주게 하려면 **Start 버튼을 누른 시각** 과 **현재 시각** 을 알고 있어야한다.

- 이러한 정보들은 화면에 렌더링되어야하는 요소이므로 아래와 같이 state로 관리하게 된다.

```javascript
const [startTime, setStartTime] = useState(null); // Start 버튼을 누른 시각
const [now, setNow] = useState(null); // 현재 시각
``` 

- 그리고 Start 버튼을 클릭했을 때 이 state들을 세팅하고, 일정주기로 now를 업데이트하는 handler를 만든다.

```javascript
function handleStart() {
  // Start를 누른 시각과 현재 시각을 모두 지금 시각으로 설정
  setStartTime(Date.now());
  setNow(Date.now());

  // 이후 10ms마다 now를 현재 시각으로 업데이트
  setInterval(() => {
    setNow(Date.now());
  }, 10);
}
```

- 이 다음 Stop 버튼을 클릭했을 때 스톱워치를 멈추게 하려면 setInterval로 만든 타이머를 clearInterval로 취소해야한다.

- clearInterval를 호출하려면 setInterval이 반환하는 interval ID가 필요하고 동시에 저장을 해야한다.

- interval ID 값은 렌더링에 필요하지않고 오직 handler에서만 필요하기 때문에 여기서 ref가 필요하다.

```javascript
import { useRef , useState } from "react";

...
const intervalRef = useRef(null); // setInterval이 반환한 interval ID를 저장
```

이후 handler를 아래와 같이 수정할 수 있다.

```javascript
function handleStart() {
  setStartTime(Date.now());
  setNow(Date.now());

  // 기존 interval이 있다면 먼저 정리
  clearInterval(intervalRef.current);

  // 새 interval을 만들고, 반환된 ID를 ref에 저장
  intervalRef.current = setInterval(() => {
    setNow(Date.now());
  }, 10);
}

function handleStop() {
  // ref에 저장해 둔 ID로 interval 정지
  clearInterval(intervalRef.current);
}
```

## state와 ref의 차이점

| 구분          | ref                                                           | state                                                             |
| ----------- | ------------------------------------------------------------- | ----------------------------------------------------------------- |
| 선언          | useRef(initialValue)는 { current: initialValue } 형태의 객체를 반환한다. | useState(initialValue)는 현재 값과 setter 함수인 [value, setValue]를 반환한다. |
| 값 변경 시 리렌더링 | current를 바꿔도 리렌더링이 일어나지 않는다.                                  | 값을 업데이트하면 컴포넌트가 리렌더링된다.                                           |
| 가변성         | 가변(mutable)이라 렌더링 과정 밖에서 current 값을 마음대로 읽고 쓸 수 있다.           | 불변(immutable) 취급이라 반드시 setter 함수를 통해서만 변경을 요청한다.                  |
| 읽기 시점       | 렌더링 중에는 ref.current를 읽거나 쓰지 않는 것이 권장된다.                       | 언제든 읽을 수 있지만, 각 렌더는 그 시점의 state 스냅샷을 보는 식으로 동작한다.                 |


## useRef의 내부동작 방식

- React 내부에서 useRef는 아래와 같이 구현되어 있다고 생각할 수 있다.

```javascript
function useRef(initialValue) {
  const [ref, unused] = useState({ current: initialValue });
  return ref;
}
````

- 첫 렌더 때 **{ current: initialValue }** 객체를 한 번 만들고, state에 저장한 뒤 이후 렌더에서도 동일한 객체를 그대로 반환한다.

- state 업데이트 함수는 사용하지 않고, 컴포넌트 쪽에서 **ref.current = ...** 처럼 직접 필드를 바꿔 리렌더링 없이 값만 바뀌는 저장소 역할을 한다.


## 언제 refs를 사용해야할까?

- 값을 저장해야할 때, 그 값이 바뀌어도 렌더링 로직이나 화면에 영향을 주지 않을때 ref를 사용한다.

## refs를 잘 사용하는 방법 

- ref는 escape hatch처럼 사용해야한다.
  - 외부 시스템이나 브라우저 API(DOM, 타이머 등)와 상호작용할 때만 최소한으로 ref를 쓰고, 애플리케이션의 주요 로직과 데이터 흐름은 state/props에 두는 것이 좋다.
  
- 렌더링 중에는 ref.current를 읽거나 쓰지 않는다.
  - 렌더링에 필요한 정보라면 ref가 아니라 state를 사용해야 한다. ref.current가 언제 바뀌는지 React는 모르기 때문에, 렌더 과정에서 이 값에 의존하면 컴포넌트 동작을 예측하기 어려워진다.
  
- state에 적용되는 제약은 ref에는 없다.
  - state는 렌더마다 스냅샷처럼 동작하고, 업데이트도 비동기 큐에 쌓이지만, ref는 그냥 JS 객체라 ref.current = 5; console.log(ref.current); 하면 즉시 5가 찍힌다. 또한 ref는 “불변성 유지”를 신경 쓸 필요가 없다. 단, 그 객체가 렌더링(화면) 계산에 사용되지 않을 때에만 마음대로 mutate해도 된다.

## ref와 DOM

- ref는 어떤 값이든 가리킬 수 있지만, 가장 흔한 사용처는 **DOM 요소** 를 가리키는 것이다.

- JSX에서 `<div ref={myRef}>` 처럼 **ref** 속성에 ref를 넘기면, React가 해당 DOM 요소를 찾아서 **myRef.current** 에 넣어 준다.

- 나중에 그 요소가 DOM에서 제거되면, React가 myRef.current를 자동으로 null로 바꿔 준다.

</br>

<a href="https://react.dev/learn/manipulating-the-dom-with-refs"><h1>Manipulating the DOM with Refs</h1></a>

- React는 렌더링 결과물에 맞춰 **DOM 변경을 자동**으로 하기 때문에 컴포넌트에서 DOM을 조작할 필요가 많이 없다.

- 하지만 **특정 노드에 포커스를 옮기거나**, **스크롤 위치를 옮기거나**, **위치와 크기를 측정** 하기 위해 React가 관리하는 **DOM** 요소에 접근해야 할 때가 있다.

- 이러한 **DOM** 에 접근하기 위해 필요한 방법이 이전 챕터에서 배운 **Ref** 이다.

## Ref로 Node 가져오기

- 아래와 같이 useRef로 ref 객체를 만들고 컴포넌트의 ref 속성에 연결하면, 해당 DOM Node가 렌더 후 ref.currnet에 들어가서 브라우저 API 등을 직접 호출할 수 있다.
 
```javascript
import { useRef } from "react";

const myRef = useRef(null);

<div ref={myRef}>...</div> // <div>의 DOM Node를 myRef.current에 넣어달라는 의미

myRef.current.scrollIntoView();  // 브라우저 API를 직접 호출할 수 있다
```

## Ref Callback으로 Ref list 관리하기

- **Hook 규칙**으로 useRef는 map안에서 사용하지 못하는데, 이러한 **동적으로 변하는 리스트의 DOM들을** 한 번에 관리하기 위해서 </br> **ref callback + Map** 을 사용한다.

## 다른 컴포넌트의 DOM nodes 접근하는 방법

- 커스텀 컴포넌트에 ref를 직접 달아도 곧바로 DOM을 가리키지 않고, 기본적으로 **null**이거나 **컴포넌트 인스턴스**를 가리킨다.

- **부모에서 만든 ref**를 **자식에게 props**처럼 내려보낸 뒤, 자식에서 그 **ref를 실제 내장 컴포넌트**(`<input>, <div>` 등)의 ref에 다시 전달해야 최종적으로 부모의 ref.current가 해당 DOM 노드를 가리키게 된다.​

## When React attaches the refs 

- React의 업데이트 과정은 총 2단계이다.
  - Render : 컴포넌트를 호출하여 화면에 무엇을 나타낼지 계산한다.
  - Commit : 변경사항을 DOM에 적용한다.
  
- Render 단계에서는 DOM이 아직 없거나 업데이트 전이라 ref.current가 null이거나 오래된 값일 수 있으므로, 이 시점에는 ref를 읽지 않는 것이 좋다.

- Commit 단계에서 React는 DOM을 바꾸기 직전에 관련된 ref.current들을 null로 초기화한 뒤 DOM을 실제로 변경하고, 곧바로 새 DOM 노드들로 각 ref.current를 다시 채운다.

- 그래서 ref를 이용한 DOM 접근·조작은 보통 클릭 같은 이벤트 핸들러나, 특정 이벤트 없이 커밋 이후에 실행되는 Effect 안에서 수행해야 안전하다.​

## Flushing state updates synchronously with flushSync

- **flushSync**는 특정 state 업데이트를 바로 DOM까지 반영한 뒤, 그 다음 코드를 실행하고 싶을 때 그 업데이트만 동기적으로 **flush** 해 주는 함수다.

## Best practices for DOM manipulation with refs

- focus, scroll 등 브라우저 API 호출처럼 렌더링에 영향이 없는 것은 Ref로 한다.

- node를 제거하거나, child를 추가, 삭제하는 등 렌더링에 영향을 주는 것은 컴포넌트 + state로 하는 것이 좋다.

<br />

<a href="https://react.dev/learn/synchronizing-with-effects"><h1>Synchronizing with Effects</h1></a>

## What are Effects and how are they different from events? 

- 렌더링 이후 **React**가 **DOM 업데이트**를 끝낸 후 실행되는 코드를 **Effect**라고 한다.
- **Rendering code**는 **순수 함수**처럼 DOM과 무관하게 계산만 수행해야 한다.
- **Event handler**는 **사용자의 명시적 인터랙션 ( 클릭, 입력 등 )** 으로 발생하지만, **Effect**는 렌더링 결과에 의해 자동으로 발생하는 **side effect**이다.

## You might not need an Effect

- Effect는 렌더링 결과를 외부 시스템( 브라우저 API, 서드 파티 위젯, 네트워크 )과 동기화할 필요가 있을 때만 필요
- Effect가 단순히 다른 상태에 기반하여 일부 상태를 조정하는 경우에는 Effect가 필요하지 않을 수 있다.

## How to write an Effect 

### Step 1 : Declare an Effect

```javascript
import { useEffect } from "react";

function MyComponent() {
  useEffect(() => {
    // 렌더링 이후 실행할 코드
  });
  return <div />;
}
```

- 기본적으로 모든 렌더링 이후에 실행된다. (의존성 배열이 없을 경우)
- DOM/외부 API 접근같은 side effect를 작성할 때 사용한다.
  
### Step 2 : Specify the Effect dependencies

```javascript
useEffect(() => {
  // effect body
}, [dep1, dep2]);
```

| 의존성 배열         | 실행 시점          |
| -------------- | -------------- |
| 없음             | 모든 렌더링 후 실행    |
| `[]` (빈 배열)    | 마운트 시 1회 실행    |
| `[dep1, dep2]` | dep가 변경될 때만 실행 |

- 의존성 배열을 통해 불필요한 실행을 막을 수 있다.
- 의존성 누락은 lint 오류가 발생하고, React가 해당 오류에 대한 수정사항을 자동으로 제안한다.

### Step 3 : Add cleanup if needed  

```javascript
useEffect(() => {
  const conn = createConnection();
  conn.connect();
  return () => {
    conn.disconnect();
  };
}, []);
```

- **Subscription, Connection, Timer** 같은 경우는 **cleanup**과 같은 **정리코드**가 필요하다.

- **cleanup** 같은 경우 Effect가 다시 실행되기 전 또는 컴포넌트 언마운트시에 실행된다.

## How to handle the Effect firing twice in development? 

- React는 **Strict Mode가 활성화된 개발 환경에서**, effect 관련 버그를 조기에 발견하기 위해
  컴포넌트를 **의도적으로 다시 마운트**하며, 그 결과 Effect가 두 번 실행되는 것처럼 보인다.

- 이러한 경우의 일반적인 해결책은 **cleanup 함수를 구현하는 것**이다.

-  Effect가 두 번 실행되는 것을 막기 위해 useRef로 실행을 제한하는 것은 **버그를 숨길 뿐 해결하지 못하므로 피해야 한다.**

### Controlling non-React widgets 

```javascript
useEffect(() => {
  const map = mapRef.current;
  map.setZoomLevel(zoomLevel);
}, [zoomLevel]);
```

- React로 작성되지 않은 외부 UI 위젯(지도, 차트 등)을 제어할 때도 Effect를 사용한다.
  
- 동일한 값을 여러 번 설정해도 문제가 없는 API라면 cleanup이 필요 없다.
  - 개발 모드에서 Effect가 두 번 실행되어도 setZoomLevel을 두 번 호출하는 것은 안전하다.
  
- 반대로, 연속 호출을 허용하지 않는 API라면 cleanup이 필요하다.

### Subscribing to events 

```javascript
useEffect(() => {
  function handleScroll(e) {
    console.log(window.scrollX, window.scrollY);
  }
  window.addEventListener('scroll', handleScroll);
  return () => window.removeEventListener('scroll', handleScroll);
}, []);
```

- Effect가 어떤 것을 subscription 한다면, cleanup 함수에서 반드시 unsubscribe 해야 한다.

### Triggering animations

```javascript
useEffect(() => {
  const node = ref.current;
  node.style.opacity = 1;
  return () => {
    node.style.opacity = 0;
  };
}, []);
```

- Effect가 요소의 애니메이션을 트리거한다면, cleanup 함수에서 초기 상태로 되돌려야 한다.

### Fetching data

```javascript
useEffect(() => {
  let ignore = false;

  async function startFetching() {
    const json = await fetchTodos(userId);
    if (!ignore) {
      setTodos(json);
    }
  }

  startFetching();

  return () => {
    ignore = true;
  };
}, [userId]);
```

- Effect가 데이터를 가져온다면, cleanup에서는 fetch를 중단(abort) 하거나 결과를 무시(ignore) 해야 한다.

- 이미 시작된 네트워크 요청은 취소할 수 없지만, 더 이상 관련 없는 응답이 state를 변경하지 않도록 보장해야 한다.

- 개발 모드에서는 네트워크 요청이 두 번 보일 수 있으나, cleanup 덕분에 첫 번째 요청 결과는 무시된다.

### Sending analytics

```javascript
useEffect(() => {
  logVisit(url);
}, [url]);
```
- 개발 환경에서는 분석 이벤트가 두 번 전송될 수 있다.

- 이는 문제가 아니며, 개발 환경에서는 로그가 실제 지표에 영향을 주지 않아야 한다.

- 빌드 환경에서는 중복 로그가 발생하지 않는다.

- 분석 디버깅이 필요하다면

  - 빌드 모드에서 실행하거나

  - Strict Mode를 일시적으로 끌 수 있다.

- 또는 Effect 대신 라우트 변경 이벤트에서 분석을 보낼 수도 있다.

### Not an Effect: Initializing the application 

```javascript
if (typeof window !== 'undefined') {
  checkAuthToken();
  loadDataFromLocalStorage();
}
```

- 애플리케이션 시작 시 단 한 번만 실행되어야 하는 로직은 Effect에 넣지 않는다.

- 컴포넌트 외부에 두면, 브라우저 로드 시 한 번만 실행됨이 보장된다.

### Not an Effect: Buying a product 

```javascript
// 잘못된 예
useEffect(() => {
  fetch('/api/buy', { method: 'POST' });
}, []);
```

- 제품 구매처럼 사용자 행동에 의해 발생해야 하는 로직은 Effect에 두면 안 된다.

- Effect는 재마운트 시 다시 실행되므로, 사용자가 의도하지 않게 중복 구매가 발생할 수 있다.

- 이런 로직은 아래와 같이 이벤트 핸들러로 옮겨야 한다.

```javascript
function handleClick() { fetch('/api/buy', { method: 'POST' }); }
```

<br />

> 7주차 두 번째

<a href="https://react.dev/learn/you-might-not-need-an-effect"><h1>You Might Not Need an Effect</h1></a>

- **Effect**는 React 패러다임(선언적 렌더링의 기본 규칙)에서 잠깐 벗어나, **non-React 위젯, 네트워크, 브라우저 DOM** 같은 **외부 시스템**과 **컴포넌트**를 동기화하기 위한 **탈출구**이다.

- 만약 이런 외부 시스템이 전혀 관여하지 않고, 단지 **props**나 **state**가 바뀔 때 그에 맞춰 컴포넌트의 state를 업데이트하고 싶은 것뿐이라면, 그런 경우에는 **Effect를 쓸 필요가 없다.**

- 이렇게 **불필요한 Effect를 제거하면**, **코드 흐름**을 **더 쉽게** 따라갈 수 있고, **렌더 사이클**이 줄어들어 **더 빠르게 실행**되며, 동기화 문제·의존성 배열 실수 같은 **에러 발생 가능성도 줄어든다.**

## How to remove unnecessary Effects

- **Effects**가 **필요하지 않는** 대표적인 두 가지 Case를 알아보자

  - **Rendering**을 위해 **transform data** 할 때 굳이 Effects를 쓸 필요가 없다.

    - **불필요한 리렌더링**을 유발할 수 있는 패턴이기 때문이다.
  
  - **User events**를 처리하는 데에는 Effect가 필요없다.

    - Effect의 실행시점에 **사용자의 행동**을 정확하게 **파악할 수 없기 때문**이다.

- 그럼 언제 **Effeects**를 사용해야할까?
  - jQuery 위젯, 브라우저 API, 서버 데이터 같은 외부 시스템과 React state를 동기화할 때 필요하고, 단순 렌더링용 데이터 변환이나 사용자 이벤트 처리에는 웬만하면 쓰지 말라는 것이다 🤔
## Updating state based on props or state 

- **어떤 state**를 기반으로 **다른 state**를 업데이트하는 관점에서 Effect와 state를 불필요하게 사용하지 말고, **기존 props·state**에서 **계산 가능한 값**은 **렌더 단계**에서 **바로 계산하는 것**이 더 **효율적**이다.

- 이렇게 하면 **연쇄적인 업데이트**로 인한 **불필요한 리렌더링**을 피할 수 있고, **코드**가 더 **단순**해지며, 여러 state 값이 서로 안 맞아서 생기는 **동기화 버그도 줄어든다.**

## Caching expensive calculations

- 기존 props 또는 state로 항상 계산 가능한 값은, 새 state + Effect로 동기화하지 말고 렌더 단계에서 바로 계산하는 것이 좋다.

- 그 계산이 expensive하다면, Effect가 아니라 useMemo 훅을 사용해 결과를 캐싱하는 것이 좋다.

- useMemo 안에 넘기는 callback 함수는 렌더링 과정에서 실행되기 때문에, **side effect 없는 pure calculation** 이어야 한다.

- React 19에서는 React Compiler가 이런 메모이제이션을 자동으로 해 주기 때문에, 원칙만 잘 지키면 수동 useMemo 사용이 훨씬 줄어들어 더 편리해졌다.

## How to tell if a calculation is expensive? 

- **console.time** / **console.timeEnd**로 계산 시간을 재서 여러 번 합산했을 때 **1ms 이상**이면 메모이제이션을 고려해볼 만한, 즉 expensive calculation일 가능성이 높다.​

- **useMemo**는 **첫 렌더**를 **빠르게 만드는 게 아니라**, 이후 렌더에서 의존성이 안 바뀐 경우 **불필요한 재계산을 건너뛰게** 해 주는 것이다.

- **개발 환경**은 **Strict Mode** 등으로 렌더가 두 번 일어나서 **수치가 부정확**하니, **프로덕션 빌드**나 **CPU Throttling**을 사용해 **실제 유저 환경과 비슷한 조건**에서 **측정**하는 게 좋다.

## Resetting all state when a prop changes 

- 아래 예시 코드는 ProfilePage 컴포넌트에서 userId를 props로 받고, 댓글 입력값을 comment state로 관리하는 상황이다. 예시로 프로필 A에서 프로필 B로 이동 시 comment가 그대로 남아, 잘못된 사용자 프로필에 댓글을 달 위험이 있다.

```javascript
export default function ProfilePage({ userId }) {
  const [comment, setComment] = useState('');

  // 🔴 Avoid: Resetting state on prop change in an Effect
  useEffect(() => {
    setComment('');
  }, [userId]);
  // ...
}
```

- 위 코드는 userId가 바뀔 때마다 Effect로 comment를 비우지만,
  - 먼저 이전 comment 값으로 한 번 렌더되고, Effect 실행 후 다시 렌더되어 비효율적이며,
  - ProfilePage 안에 state가 여러 개 있으면 모든 하위 컴포넌트마다 이런 Effect를 반복해서 작성해야 해 구조가 복잡해진다.​

- 그래서 아래 코드처럼 Profile에 key={userId}를 주어, React가 각 userId를 서로 다른 컴포넌트 인스턴스로 인식하게 만들어야 한다. 이렇게 하면 userId가 바뀔 때마다 Profile과 그 아래 모든 state가 자동으로 리셋되고, 댓글 입력값도 자연스럽게 초기화된다.
​
```javascript
export default function ProfilePage({ userId }) {
  return (
    <Profile
      userId={userId}
      key={userId}
    />
  );
}

function Profile({ userId }) {
  // ✅ This and any other state below will reset on key change automatically
  const [comment, setComment] = useState('');
  // ...
}
```

​ - 그렇기에 결론적으로, props 변화에 따라 컴포넌트 안의 여러 state를 한 번에 초기화하고 싶을 때는, Effect로 각각의 state를 비우기보다 key를 사용해서 컴포넌트 인스턴스를 갈아끼우는 방식으로 전체 state를 리셋하는 것이 더 단순하고 효율적이다. 이렇게 하면 불필요한 리렌더와 중복 초기화 코드를 줄이면서도, userId마다 완전히 독립적인 상태를 보장할 수 있다.
​
## Adjusting some state when a prop changes 

- 이번에는 전체 state 초기화가 아닌 일부 state를 재설정하거나 초기화하는 경우를 알아보자

- 아래 코드처럼 Effect에서 prop 변경시 state를 조정하는 방식은 비효율적이라고 볼 수 있다.

```javascript
function List({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selection, setSelection] = useState(null);

  // 🔴 Avoid: Adjusting state on prop change in an Effect
  useEffect(() => {
    setSelection(null);
  }, [items]);
  // ...
}
```

- 위 코드 대신, 아래 코드처럼 “선택된 아이템 전체”를 state로 들고 있지 말고, ID만 state로 저장해 두고 렌더 단계에서 selection을 계산하는 방식이 가장 단순하고 안전하다.
​
```javascript
function List({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selectedId, setSelectedId] = useState(null);
  // ✅ Best: Calculate everything during rendering
  const selection = items.find(item => item.id === selectedId) ?? null;
  // ...
}
```

- 이렇게 하면 items가 바뀌어도 Effect로 selection을 리셋하거나 조정할 필요 없이, 항상 현재 items와 selectedId를 기준으로 selection이 자동으로 일관되게 계산된다.

## Sharing logic between event handlers 

<a href="https://react.dev/learn/you-might-not-need-an-effect#sharing-logic-between-event-handlers">예시 코드</a>

- 이벤트 핸들러 간 로직을 공유할 때는, 그 로직이 “컴포넌트가 화면에 표시됐기 때문에” 실행되어야 하는지, 아니면 “사용자 이벤트(클릭 등) 때문에” 실행되어야 하는지를 기준으로 Effect에 둘지 이벤트 핸들러에 둘지를 결정해야 한다.

- 예시 코드에서는 알림이 “페이지가 렌더링되었다”는 사실 때문에 실행되는 것이 아니라 “사용자가 버튼을 눌렀다”는 상호작용 때문에 실행되어야 하므로, Effect가 아니라 각 버튼의 이벤트 핸들러에서 공유 함수를 호출하는 방식이 맞다.

## Sending a POST request

<a href="https://react.dev/learn/you-might-not-need-an-effect#sending-a-post-request">예시 코드</a>

- POST 요청 로직을 어디에 둘지 결정할 때 가장 중요한 점은, 그 로직이 “컴포넌트가 화면에 표시됐기 때문에” 실행되어야 하는지, 아니면 “사용자 상호작용(버튼 클릭 등) 때문에” 실행되어야 하는지 기준을 세우는 것이다.

- 예시 코드에서는 analytics 이벤트처럼 폼이 표시될 때 한 번 실행돼야 하는 로직은 Effect 안에 두고, 회원가입 /api/register 요청처럼 사용자가 버튼을 클릭했을 때만 실행돼야 하는 로직은 Effect가 아닌 이벤트 핸들러 내부에 두어야 한다.

## Chains of computations

<a href="https://react.dev/learn/you-might-not-need-an-effect#chains-of-computations">예시 코드</a>

-  여러 state를 서로 Effect로 체이닝해서 업데이트하면 불필요한 리렌더링이 많이 발생하고, 이전 state를 복원할 때 체인이 다시 트리거되는 등 구조가 취약해지므로 피하는 것이 좋다.

- 이 예시에서는 isGameOver처럼 렌더링 중에 계산 가능한 값은 렌더링에서 직접 계산하고, place card와 관련된 연속적인 state 변경(card, goldCardCount, round, 알림 표시)은 하나의 이벤트 핸들러 안에서 한 번에 처리하도록 구조를 바꾸는 것이 더 효율적이고 요구사항 변화에도 유연하다.​

## Initializing the application

<a href="https://react.dev/learn/you-might-not-need-an-effect#initializing-the-application">예시 코드</a>

- 앱이 로드될 때 한 번만 실행되어야 하는 로직을 단순히 최상위 컴포넌트의 Effect에 넣으면, 개발 모드에서 Effect가 두 번 실행되기 때문에 인증 토큰 무효화 같은 문제가 생길 수 있어 지양해야 한다.

- 이런 종류의 초기화 로직은 “컴포넌트 마운트당 한 번”이 아니라 “앱 로드당 한 번”만 실행되어야 하므로, 최상위 스코프에 didInit 같은 변수를 두고 실행 여부를 추적하거나, 아예 모듈 초기화 단계에서 한 번만 실행되도록 분리해 App.js나 엔트리 포인트에 배치하는 것이 권장된다.​

## Notifying parent components about state changes

<a href="https://react.dev/learn/you-might-not-need-an-effect#notifying-parent-components-about-state-changes">예시 코드</a>

- 자식 컴포넌트의 state 변경을 부모에게 알릴 때, Effect 안에서 부모의 onChange를 호출하면 자식이 먼저 렌더링된 뒤 부모가 다시 렌더링되는 두 번의 패스가 생겨 비효율적이므로, 하나의 이벤트 흐름 안에서 자식과 부모 state를 함께 업데이트하는 것이 좋다.

- 예시처럼 updateToggle 함수 안에서 setIsOn과 onChange를 동시에 호출하거나, 아예 Toggle의 state를 없애고 isOn을 부모로부터 완전히 제어받도록 “state 끌어올리기”를 적용하면, 두 컴포넌트가 한 번의 렌더링 패스로 동기화되고 관리해야 할 state도 줄어든다.

## Passing data to the parent 

<a href="https://react.dev/learn/you-might-not-need-an-effect#passing-data-to-the-parent">예시 코드</a>

- React에서는 데이터 흐름이 기본적으로 부모 → 자식 방향이기 때문에, 자식이 Effect 안에서 부모의 state를 직접 갱신하게 만들면 데이터의 출발점을 추적하기 어려워져 흐름이 복잡해진다.

- 이 예시에서는 자식과 부모가 같은 데이터를 필요로 하므로, 데이터를 가져오는 책임을 부모 컴포넌트로 올리고(useSomeAPI를 부모에서 호출), 그 결과를 props로 자식에게 내려보내도록 “state 끌어올리기”를 적용하면, 데이터가 항상 부모에서 자식으로만 내려가서 흐름이 단순하고 예측 가능하게 유지된다.​

## Subscribing to an external store 

<a href="https://react.dev/learn/you-might-not-need-an-effect#subscribing-to-an-external-store">예시 코드</a>

- 기존 Effect 기반 패턴

  - 예시 코드에서는 navigator.onLine 값을 읽어와 isOnline state로 옮기고, online/offline 이벤트 리스너를 Effect에서 수동으로 등록,해제하는 useOnlineStatus 훅을 먼저 보여준다.

  - 이 방식은 “외부 저장소 → React state”로 일일이 옮겨 적는 구조라, 변경 가능한 데이터를 수동으로 동기화해야 해서 실수 가능성이 크고 유지보수가 어렵다는 단점이 있다.

- useSyncExternalStore 패턴

  - 위와 같은 방식을 useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot)으로 바꾸면, subscribe에서 이벤트 리스너 등록/해제를 정의하고 navigator.onLine을 스냅샷 함수로 바로 읽게 되어, 외부 저장소를 React가 공식적으로 지원하는 방식으로 subscribe 할 수 있다.

## Fetching data

<a href="https://react.dev/learn/you-might-not-need-an-effect#fetching-data">예시 코드</a>

- 많은 앱에서 검색 결과 같은 데이터를 가져올 때 useEffect를 사용하며, SearchResults 예제처럼 query와 page 값에 맞춰 results를 서버 데이터와 계속 동기화한다. 이 경우 핵심 요구사항은 “사용자가 어떻게 여기까지 왔든, 이 컴포넌트가 보이는 동안 현재 query/page에 해당하는 데이터가 항상 맞게 떠 있어야 한다”이기 때문에, 특정 클릭 이벤트가 아니라 Effect에서 fetch를 트리거하는 것이 적절한 선택이 된다.

- 단순 구현으로는 “race condition” 이라는 문제가 생긴다. 사용자가 "hello"를 빠르게 입력하면 "h", "he", "hel" 등 여러 요청이 거의 동시에 날아가는데, "hello" 요청보다 "hel" 응답이 더 늦게 도착하면 오래된 결과가 마지막에 setResults를 호출해서 화면이 잘못된 검색어의 결과로 덮어쓰인다. 이를 막기 위해 Effect 안에서 let ignore = false 같은 플래그를 두고, fetch 응답에서 if (!ignore) setResults(json)으로 체크한 뒤 정리 함수에서 ignore = true로 바꿔 주면, 이전 렌더에서 시작된 모든 요청 응답은 무시되고 “마지막 렌더에서 만든 요청의 응답만 유효”하게 된다.

- 같은 패턴을 여러 곳에 복사하기보다는, useData(url)처럼 커스텀 훅으로 추상화하는 편이 좋다. 이 훅 안에서 fetch, 정리, 에러 처리, 로딩 상태 관리까지 한 번에 처리해 두면, 화면 컴포넌트는 const results = useData(url)처럼 선언적으로 사용할 수 있고, 나중에 프레임워크 내장 데이터 패칭이나 다른 방식으로 변경할 때도 호출부는 거의 건드리지 않고 내부 구현만 교체하면 된다.
