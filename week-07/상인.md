# Referencing Values with Refs

## ref를 사용하는 이유

컴포넌트가 특정 정보를 기억하고 싶을 때, 렌더링을 trigger 하지 않고 싶을 때 ref를 사용할 수 있다.

`state`는 값이 바뀌면 렌더링을 trigger 하지만, ref는 값이 바뀌어도 trigger 하지 않는다.

## useRef

`useRef` hook을 사용해서 ref를 사용할 수 있다.

```jsx
import { useRef } from "react";

const ref = useRef(initialValue); // current 값으로 전달
```

`useRef`의 반환값은 아래와 같은 객체이다.

```json
{
  "current": initialValue
}
```

`current` 값은 **mutable** 하며 React 에서는 이 값의 변경을 추적하지 않는다.

따라서 React의 **단방향 데이터 흐름**에서 벗어나는 탈출구 역할을 한다.

아래 예시에서는 버튼을 클릭할 때마다 `ref.current`를 1씩 증가시키고 있지만, 렌더링을 trigger하지 않는다.

```jsx
import { useRef } from "react";

export default function Counter() {
  let ref = useRef(0);

  function handleClick() {
    ref.current = ref.current + 1;
    alert("You clicked " + ref.current + " times!");
  }

  return <button onClick={handleClick}>Click me!</button>;
}
```

state를 사용했더라면 렌더링을 trigger 할 것이다.

```jsx
export default function Counter() {
  const [count, setCount] = useState(0);

  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

## state + ref

아래는 state 와 ref를 함께 사용한 예시 코드이다.

```jsx
import { useState, useRef } from "react";

export default function Stopwatch() {
  const [startTime, setStartTime] = useState(null);
  const [now, setNow] = useState(null);
  const intervalRef = useRef(null);

  function handleStart() {
    setStartTime(Date.now());
    setNow(Date.now());

    clearInterval(intervalRef.current);
    intervalRef.current = setInterval(() => {
      setNow(Date.now());
    }, 10);
  }

  function handleStop() {
    clearInterval(intervalRef.current);
  }

  let secondsPassed = 0;
  if (startTime != null && now != null) {
    secondsPassed = (now - startTime) / 1000;
  }

  return (
    <>
      <h1>Time passed: {secondsPassed.toFixed(3)}</h1>
      <button onClick={handleStart}>Start</button>
      <button onClick={handleStop}>Stop</button>
    </>
  );
}
```

**interval ID**는 실제로 보여주지는 않고 이벤트 핸들러에서 필요한 정보이다.

화면에 그릴 필요가 없는 **interval ID**는 ref로 관리하고, 화면에 그리는 값들은 state로 관리하는 모습을 보여준다.

## ref vs state

### ref

1. 렌더링 trigger X
2. mutable
3. 렌더링 중에 읽기, 사용 X

3번 예시

```jsx
import { useRef } from "react";

export default function Counter() {
  let ref = useRef(0);

  function handleClick() {
    ref.current = ref.current + 1;
    alert("You clicked " + ref.current + " times!");
  }

  return <button onClick={handleClick}>{ref.current}</button>;
}
```

`ref.current`를 렌더에 사용하면 alert가 열렸을 때는 증가된 값이 보이지만 실제 버튼에는 리렌더링이 일어나지 않았기 때문에 처음 값 그대로이다.

정리하면 `ref.current`는 렌더링으로부터 자유롭지만, 렌더링 결과를 바꾸고 싶을 때 사용하면 안된다.

### state

1. 렌더링 trigger O
2. immutable
3. 언제든 읽을 수 있지만, 각 렌더는 자신의 스냅샷을 가진다.

## ref를 언제 사용하는가?

브라우저 API와 통신할 때 주로 사용

또,

- setTimeout ID 저장
- DOM 조작 (querySelector)
- JSX 계산에 필요하지 않은 기타 객체 저장

ref에 많은 의존을 하는 것보다는 state로 먼저 풀고, 불필요한 렌더링이 보일 때 ref를 사용하는 방식으로 접근하는 것이 좋을 것 같다.

# Manipulating the DOM with Refs

React에서 focus, scroll 등 DOM 요소에 이벤트를 주거나 접근해야 할 때, ref를 이용한다.

## ref로 DOM 노드에 접근하기(얻기)

아래 예시 코드는 ref값을 만들고, JSX의 요소에(input 태그) ref값을 전달해준 코드이다.

```jsx
import { useRef } from "react";

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

`inputRef`의 초기값은 `null`이고, React가 input을 만들면(DOM 노드를 만들면) `inputRef.current`에 참조값을 전달한다.

```jsx
// inputRef.current 출력

HTMLInputElement {
  value: "",
  type: "text",
  focus: ƒ,
  blur: ƒ,
  ...
}
```

> 컴포넌트 내에서 여러 Ref를 선언할 수 있다.
>
> 실제로 Carousel같은 스크롤과 관련된 UI를 사용할 때 ref를 리스트로 관리하는 패턴도 사용된다.

## 다른 컴포넌트 DOM 노드에 접근

아래 코드는 부모 컴포넌트에서 ref를 만들어 자식 컴포넌트로 일반 prop처럼 넘기는 예시 코드이다.

```jsx
import { useRef } from "react";

function MyForm() {
  const inputRef = useRef(null);
  return <MyInput ref={inputRef} />;
}

function MyInput({ ref }) {
  return <input ref={ref} />;
}
```

> 회사에서는 `forwardRef`로 작성된 코드를 더 많이 보지 않을까?
>
> ```jsx
> const MyInput = forwardRef((props, ref) => {
>   return <input ref={ref} />;
> });
> ```

## useImperativeHandle

위 코드처럼 ref prop을 바로 사용하기 보다는 `useImperativeHandle` hook 을 사용해서 특정 메서드만 포함한 객체를 직접 구성 -> 컴포넌트 외부로 노출(부모 컴포넌트에게 전달)하도록 해서 예상치 못한 동작을 방지할 수 있다.

```jsx
import { useRef, useImperativeHandle } from "react";

function MyInput({ ref }) {
  const realInputRef = useRef(null);
  useImperativeHandle(ref, () => ({
    focus() {
      realInputRef.current.focus();
    },
    reset() {},
    blur() {},
    ...
  }));
  return <input ref={realInputRef} />;
}

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

## React는 ref를 언제 붙이는지

React는 커밋 시점에 `ref.current`를 설정한다.

React의 업데이트 과정은 렌더링 과정에서 무엇을 화면에 보여줄 지 계산, 결정하고, 커밋 과정에서 실제 DOM에 적용한다.

DOM 노드가 업데이트 되기 전에 `ref.current`에 노드를 붙이기에는 너무 성급하다. 따라서 렌더링 과정에서는 `ref.current`를 `null`로 초기화 하고, 커밋 과정에서 DOM 노드를 붙인다.

앞선 정리에서 **ref를 리렌더링을 기대하면서 사용하지 마라** 라고 정리했었는데, 정확히 ref를 렌더링 과정에서 읽거나 사용하지 말라고 하는 이유를 이 부분(렌더링 중에 DOM을 신뢰할 수 없는)이 설명해주는 것 같다.

## DOM을 안전하게 조작

아래 예시 코드에서 remove 이후에 show 버튼을 클릭하면 충돌이 난다.

```jsx
import { useState, useRef } from "react";

export default function Counter() {
  const [show, setShow] = useState(true);
  const ref = useRef(null);

  return (
    <div>
      <button
        onClick={() => {
          setShow(!show);
        }}
      >
        Toggle with setState
      </button>
      <button
        onClick={() => {
          ref.current.remove();
        }}
      >
        Remove from the DOM
      </button>
      {show && <p ref={ref}>Hello world</p>}
    </div>
  );
}
```

지금 React는 show 상태에 따라서 DOM 노드를 관리하고 있는데, 외부 동작으로 DOM 노드를 제거 해버리면서 생기는 충돌이다.

DOM 노드의 구조를 파괴하지 않는 `focus, scroll` 등의 이벤트는 안전하지만 React가 관리하는 DOM 노드는 가능한 한 수정하지 않아야 한다.

# Synchronizing with Effects

## Effect 와 Event

컴포넌트의 두 가지 로직

- 렌더링 코드는 순수해야 하고, side effect가 없어야한다.
- 이벤트 핸들러는 side effect를 포함한다.

이벤트만으로는 해결되지 않는 상황도 있다.

예를 들어 채팅 기능에서 메시지 전송은 사용자의 클릭이나 입력에 의해 발생하는 이벤트이지만,

채팅에 접속하고 서버와 연결을 유지하는 과정은 특정 사용자 행동이 아니라 현재 어떤 채팅방에 있는지라는 상태 변화에 따라 자동으로 동기화되어야 하는 로직이다.

이런 경우에는 이벤트만으로는 처리할 수 없으며, **Effect**가 필요하다.

- 이벤트: user action으로 발생 (채팅창 나가기)
- Effect: UI 렌더링 이후(커밋 과정 이후) 업데이트의 결과로 인해서 발생 (채팅창 나가면 연결 끊기기)

## Effect 사용방법

### useEffect로 선언

```jsx
import { useEffect } from "react";

function MyComponent() {
  useEffect(() => {
    ...
  });
  return <div />;
}
```

`useEffect` 내부 코드는 UI 업데이트 이후 실행된다.

비디오 플레이어 예시

```jsx
import { useState, useRef, useEffect } from "react";

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  if (isPlaying) {
    ref.current.play();
  } else {
    ref.current.pause();
  }

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  return (
    <>
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? "Pause" : "Play"}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}
```

위 예시는 상태 변화에 따른 렌더링 중에 DOM을 조작하기 때문에 올바르지 않은 코드이다.

DOM을 조작하는 부분을 Effect 안으로 옮겨야 한다.

```jsx
import { useEffect, useRef } from "react";

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}
```

> Effect는 렌더링 이후에 실행 -> Effect 내부 setState로 무한 루프에 빠지지 않게 주의

### deps

기본적으로 Effect는 매 렌더링 후에 실행된다. deps 배열을 넘기면 deps의 값들이 이전 렌더링과 같을 경우에는 Effect가 재실행 되지 않는다.

```jsx
useEffect(() => {
  // 매 렌더 후 실행
});

useEffect(() => {
  // 마운트될 때 실행
}, []);

useEffect(() => {
  // a 혹은 b가 바뀔 때 실행
}, [a, b]);
```

### cleanup

```jsx
export function createConnection() {
  return {
    connect() {
      console.log("✅ Connecting...");
    },
    disconnect() {
      console.log("❌ Disconnected.");
    },
  };
}

import { useEffect } from "react";
import { createConnection } from "./chat.js";

export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
  }, []);
  return <h1>Welcome to the chat!</h1>;
}
```

위 코드를 출력해보면 Connecting 이 두 번 출력되는 것을 확인할 수 있다.

이는 버그가 아니고, React가 dev mode에서 연결이 제대로 해제 되었는지 검증하기 위한 내부적인 동작이다.

두 번 출력되는 것은 컴포넌트가 언마운트 됐을 때 cleanup이 되지 않는다는 것을 확인시켜준다.

cleanup 함수를 호출해서 언마운트 시에 연결을 해제하여 해결할 수 있다.

```jsx
useEffect(() => {
  const connection = createConnection();
  connection.connect();
  return () => {
    connection.disconnect();
  };
}, []);
```

> Effect의 두 번 실행을 ref로 막지 말기
>
> ```jsx
> const connectionRef = useRef(null);
> useEffect(() => {
>   if (!connectionRef.current) {
>     connectionRef.current = createConnection();
>     connectionRef.current.connect();
>   }
> }, []);
> ```
>
> 언마운트 후 연결을 해제하는 것이 아닌 알려주는 경고를 가려 버리는 꼴이다.

## 여러 Effect 예시들

### 외부 위젯

두 번 호출해도 문제가 없는 경우 cleanup 호출 필요 X

```jsx
useEffect(() => {
  const map = mapRef.current;
  map.setZoomLevel(zoomLevel);
}, [zoomLevel]);
```

showModal과 같은 두 번 호출했을 경우 문제가 생긴다면 cleanup 호출

```jsx
useEffect(() => {
  const dialog = dialogRef.current;
  dialog.showModal();
  return () => dialog.close();
}, []);
```

### 이벤트 구독

addEventListener로 이벤트를 구독하면 cleanup 호출

```jsx
useEffect(() => {
  function handleScroll(e) {
    console.log(window.scrollX, window.scrollY);
  }
  window.addEventListener("scroll", handleScroll);
  return () => window.removeEventListener("scroll", handleScroll);
}, []);
```

### 애니메이션 트리거

특정 요소를 애니메이션으로 표시할 때 cleanup 호출

```jsx
useEffect(() => {
  const node = ref.current;
  node.style.opacity = 1;
  return () => {
    node.style.opacity = 0;
  };
}, []);
```

### fetch data

ignore를 이용해서 cleanup에서 유효하지 않은 response를 무시

```jsx
useEffect(() => {
  let ignore = false;

  async function startFetching() {
    const json = await fetchTodos(userId);
    if (!ignore) {
      setTodos(json);
    }
  }

  startFetching();

  return () => {
    ignore = true;
  };
}, [userId]);
```

## Effect가 아닌 것들

### 상품 구입(POST)

POST를 Effect에 넣으면, 페이지 재방문이나 뒤로 가기 시 다시 호출될 수 있어 위험하다

```jsx
function handleClick() {
  fetch("/api/buy", { method: "POST" });
}
```

### 앱 초기화

앱 전체에서 한 번만 실행해야 하는 코드는 컴포넌트 밖에서 실행

```jsx
if (typeof window !== "undefined") {
  checkAuthToken();
  loadDataFromLocalStorage();
}

function App() {
  // ...
}
```

> 각 렌더의 고유한 Effect
>
> 각 렌더는 자기만의 Effect를 갖고, cleanup은 그 렌더에 해당하는 Effect만 정리한다
