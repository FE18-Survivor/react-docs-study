# Week 03

(11.21 금)

## Render and Commit

> 컴포넌트가 화면에 보여지기 전에 어컴포넌트들은 리액트에 의해 렌더링 됩니다. 해당 단계들을 알아보겠습니다.

- 리액트에서의 랜더링의 의미
- 언제, 왜 리액트가 컴포넌트를 렌더링 하는지
- 컴포넌트가 화면에 보여질때의 단계
- 왜 렌더링할때 항상 DOM update를 생성하지 않는지

React는 간단하게 세 단계로 컴포넌트를 스크린에 나타냅니다.

1. Triggering a render
2. Rendering th component
3. Committing to the DOM

### Step 1: Trigger a render

컴포넌트가 렌더링 될땐 두가지 경우가 있습니다.

1. 초기 렌더링을 할때
2. 컴포넌트나 부모컴포넌트에 업데이트가 발생했을때

**Initial render**

리액트에서 초기렌더링은 `createRoot`를 호출하고, `render` 메소드를 통해 진행됩니다.

```javascript
import Image from "./Image.js";
import { createRoot } from "react-dom/client";

const root = createRoot(document.getElementById("root"));
root.render(<Image />);
```

**Re-renders when state updates**

컴포넌트가 초기렌더링 된 후, state가 변경이 되면 자동으로 렌더링 큐에 들어가서 업데이트 됩니다.

### Step 2: React renders your components

"Rendering"은 리액트가 컴포넌트를 호출하는 것입니다.

이러한 호출은 재귀적입니다. 업데이트된 컴포넌트가 다른 컴포넌트를 반환하면 리액트는 그것또한 렌더링 할것이기 때문입니다. 중첩된 컴포넌트가 없을때까지 진행되고 그 후에 화면에 어떻게 나타낼지 결정됩니다.

렌더링 유의사항

- 동일 인풋, 동일 아웃풋 : 똑같은 input이 있으면 리액트는 동일한 JSX를 반환해야합니다.
- 렌더링은 렌더링만 해야합니다 : 렌더링 전에 존재하는 다른 객체나 변수들을 변경하면 안됩니다.

### Step 3: React commits changes to the DOM

렌더링을 하면 리액트는 DOM을 수정합니다.

- initial render : `appendChild()` DOM API를 사용하여 DOM nodes를 화면에 그려냅니다.
- 그 이후 render : 렌더링 중에 계산을 통해 최소한의 필요한 부분만 DOM이 바뀌도록 합니다.

**리액트는 렌더링간에 차이가 있을때만 DOM node들을 변경합니다.**

### Browser paint

렌더링이 끝난 후 리액트가 DOM을 업데이트 하면 브라우저는 "browser rendring" 이라 불리는 작업, 화면을 repaint를 진행합니다.

<br />

## State as a Snapshot

state는 JS변수와 비슷하게 보이지만, 변수보단 snapshot 같습니다. 기존의 값을 변경해서 state의 값을 설정하는 것이 아니라 re-render의 trigger를 하여 설정합니다.

- state로 re-render의 trigger를 하는 방법
- 언제, 어떻게 state를 업데이트 하는지
- 왜 state는 즉시 업데이트 되지 않는지
- 이벤트 핸들러는 어떻게 state에 접근하는지

### Setting state triggers renders

리액트에선 사용자와 상호작용하는 이벤트(click, typing, etc)를 화면에 나타내려면 state를 업데이트 해야합니다. 따라서 이벤트 핸들러에서 state를 변경하고 리액트가 re-render 됩니다.

### Rendering takes a snapshot in time

렌더링이 리액트가 컴포넌트를 호출한다고 했고, 컴포넌트는 함수입니다. 따라서 렌더링이 발생할때 JSX는 함수를 snapshot처럼 반환합니다. props, 이벤트 핸들러, 변수들까지 전부 렌더링 할때를 기준으로 계산됩니다.

컴포넌트의 메모리인 state는 일반 변수와 다르게 사라지지 않습니다. 컴포넌트가 렌더링되면 그 순간의 state의 모습이 snapshot처럼 전달됩니다.

```javascript
import { useState } from "react";

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}
      >
        +3
      </button>
    </>
  );
}
```

따라서 위와같은 코드에서 버튼을 누를때 `setNumber(number+1)`함수가 3번 호출되어도 state인 number는 항상 0이기 때문에 숫자는 3이 아닌 1씩 증가합니다.

```javascript
import { useState } from "react";

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          alert(number);
        }}
      >
        +5
      </button>
    </>
  );
}
```

위와 같은 코드에서 버튼을 누르면 alert창은 어떻게 보일까요?
처음 클릭한다면 alert창엔 0이 보일것입니다.

click을 통해 state 변수(number)가 업데이트 되었고, 그때 number의 값은 `0`이기 때문에 alert엔 `0`으로 보입니다. update된 number(`5`)는 그 이후 버튼을 클릭해야 alert에 보이게 됩니다.

따라서 state가 업데이트 된 후 그 state를 alert으로 보여주고 싶다면, state값을 변경하는 핸들러와 alert 핸들러를 분리해야 합니다.

<br />

## Queueing a Series of State Updates

- "batching"이 무엇이고, react에서 multiple state update를 어떻게 진행하는지
- 동일한 state 변수에 어떻게 여러 업데이트를 적용하는지

리액트는 event handler에 있는 모든 코드가 끝나기 전까지 state를 업데이트 하거나 UI를 변경하지 않습니다. 그렇기 때문에 triggering이 많이 발생하지 않고 여러 컴포넌트에서 다수의 state가 변경할 수 있게 됩니다. 이것을 **batching** 이라고 하며 react app이 빠르게 실행될 수 있게 해줍니다.

batching을 통해 클릭 같은 여러번 발생될 수 있는 이벤트를 동시에 처리하지 않고 하나씩 개별적으로 처리합니다.

### Updating the same state multiple times before the next render

흔한 경우는 아니지만 동일한 state 변수를 한번에 여러번 변경해야 할 경우가 있을 수 있습니다. 그럴땐 함수를 전달해주면 가능합니다.

```javascript
import { useState } from "react";

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber((n) => n + 1);
          setNumber((n) => n + 1);
          setNumber((n) => n + 1);
        }}
      >
        +3
      </button>
    </>
  );
}
```

`setNumber(n => n + 1)`에서 `(n => n + 1)`가 함수이기 때문에 react가 queue에 추가합니다. useState가 실행되며 `(n => n + 1)` 함수가 실행되기 때문에 n의 값을 확인하고 n에 1씩 더해지게 됩니다.

```javascript
<button
  onClick={() => {
    setNumber(number + 5);
    setNumber((n) => n + 1);
  }}
>
  Increase the number
</button>
```

onClick의 함수를 다음과 같이 바꾸면 number는 6씩 오르게 됩니다. 이번에도 number + 5가 실행된 후 `(n => n + 1)`함수가 실행되기 때문입니다.

```javascript
<button
  onClick={() => {
    setNumber(number + 5);
    setNumber((n) => n + 1);
    setNumber(number + 3);
    setNumber((n) => n + 1);
  }}
>
  Increase the number
</button>
```

onClick 함수가 다음과 같이 바뀐다면 number는 4씩 올라가게 됩니다.

| queued update | n   | returns     |
| ------------- | --- | ----------- |
| replaced `5`  | 0   | `5`         |
| `n => n + 1`  | 5   | `5 + 1 = 6` |
| replaced `3`  | 0   | `3`         |
| `n => n + 1`  | 3   | `3 + 1 = 4` |

### Naming convention

useState에 함수를 넣어 업데이트를 할때 다음과 같이 argument 이름을 지어주는 것이 보편적인 방법입니다.

```javascript
setEnabled((e) => !e);
setLastName((ln) => ln.reverse());
setFriendCount((fc) => fc * 2);
```
