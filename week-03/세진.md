# Week 03

(11.18 화)

## Responding to Events

> 여러 interaction이 발생했을때 JSX에 이벤트 핸들러를 추가하여 응답하는 함수를 적용할 수 있습니다.

### Adding event handlers

1. 함수를 만들어서 prop으로 전달하기

```javascript
export default function Button() {
  function handleClick() {
    alert("You clicked me!");
  }

  return <button onClick={handleClick}>Click me</button>;
}
```

`handleClick`이란 함수를 만들어서 button JSX 태그에 onClick이라는 prop으로 전달합니다. 버튼이 클릭되면 handleClick 함수가 실행됩니다.

2. inline으로 작성하기 (1)

```javascript
<button onClick={function handleClick() {
  alert('You clicked me!');
}}>
```

3. inline으로 작성하기 (2)

```javascript
<button onClick={() => {
  alert('You clicked me!');
}}>
```

JSX 태그 내부에 표현식 방식이나 화살표 함수 형태로 작성할 수 있습니다.

**유의할 점**

함수를 이벤트 핸들러로 전달할땐 호출되어서는 안됩니다. 쉽게 말하면 작성할때 소괄호'()'를 같이 적으면 안됩니다.

`onClick={handleClick}` ✅ <br/>
`onClick={handleClick()}` ❌

소괄호가 있으면 JSX에 있는 자바스크립트가 바로 실행되기 때문에 이벤트 핸들러로 작동하지 않게 됩니다.

### Props와 Event Handler

#### 1. event handler에서 props 읽기

이벤트 핸들러가 컴포넌트 내부에서 선언되기 때문에 이벤트 핸들러 또한 컴포넌트의 props에 접근할 수 있습니다. 따라서 아래와 같은 코드가 있을때, props로 넘겨받는 `message`와 `children` 모두 이벤트 핸들러에서 해당변수의 값을 확인할 수 있습니다.

```javascript
function AlertButton({ message, children }) {
  return <button onClick={() => alert(message)}>{children}</button>;
}

export default function Toolbar() {
  return (
    <div>
      <AlertButton message="Playing!">Play Movie</AlertButton>
      <AlertButton message="Uploading!">Upload Image</AlertButton>
    </div>
  );
}
```

#### 2. event handler를 props로 전달하기

부모컴포넌트가 자식컴포넌트의 이벤트 핸들러를 정의하고 싶을때가 있다면 이벤트 핸들러를 만들고 자식 컴포넌트는 해당 함수를 props로 받을 수 있게 구현하면 됩니다.

```javascript
function Button({ onClick, children }) {
  return <button onClick={onClick}>{children}</button>;
}

function PlayButton({ movieName }) {
  function handlePlayClick() {
    alert(`Playing ${movieName}!`);
  }

  return <Button onClick={handlePlayClick}>Play "{movieName}"</Button>;
}

export default function Toolbar() {
  return (
    <>
      <PlayButton movieName="Kiki's Delivery Service" />
    </>
  );
}
```

Button 이라는 자식 컴포넌트는 props로 onClick이라는 이름의 event handler를 전달받게 됩니다. 부모 컴포넌트에서 원하는 함수를 정의하고(`handlePlayClick`), 자식컴포넌트에 props로(`onClick`) 전달하여 handler가 실행됩니다.

#### 3. Naming event handler props

`<button>`이나 `<div>` 같은 기본 제공 컴포넌트(Built-in components)는 `onClick` 같은 browser event name만 지원하지만 직접 만든 컴포넌트라면 props 이름을 마음대로 지을 수 있습니다.

```javascript
function Button({ onSmash, children }) {
  return <button onClick={onSmash}>{children}</button>;
}

export default function App() {
  return (
    <div>
      <Button onSmash={() => alert("Playing!")}>Play Movie</Button>
      <Button onSmash={() => alert("Uploading!")}>Upload Image</Button>
    </div>
  );
}
```

event handler가 onSmash라는 이름의 props로 전달이 되고, 자식컴포넌트인 button에선 onClick으로 핸들러가 실행이 됩니다. 따라서 event handler는 해당 핸들러가 어떤 행동을 하는지 작성하여 코드의 가독성을 높일 수 있습니다.

### Event propagation (이벤트 전파)

이벤트 핸들러는 자식 컴포넌트에서 발생한 이벤트를 감지할 수 있습니다. `onScroll`을 제외하고 리액트에서 발생하는 이벤트들은 JSX 태그의 작성 순서대로 전파됩니다.

이벤트전파는 `stopPropagation()` 함수를 통해 막을 수 있습니다.

```javascript
function Button({ onClick, children }) {
  return (
    <button
      onClick={(e) => {
        e.stopPropagation();
        onClick();
      }}
    >
      {children}
    </button>
  );
}
```

위처럼 작성하면 이벤트의 전파는 막고, props로 전달받은 onClick 핸들러만 동작하게 됩니다.

> 종종 자식 컴포넌트는 전부 이벤트 전파를 막았지만 모든 이벤트를 로그에 남겨야 할 수도 있습니다. 그럴땐 핸들러 뒤에 `Capture`를 작성하여 해결할 수 있습니다.

```javascript
<div
  onClickCapture={() => {
    /* this runs first */
  }}
>
  <button onClick={(e) => e.stopPropagation()} />
  <button onClick={(e) => e.stopPropagation()} />
</div>
```

**Event handlers는 side effect가 발생합니다**

<br />

## State: A Component's Memory

- `useState`hook을 통해 state의 값을 어떻게 바꾸는지
- `useState`hook이 반환하는 값은 무엇인지
- 어떻게 여러 값을 더할 수 있는지
- 왜 state는 local이라 불리는지

### state가 있는 이유

일반 변수로는 컴포넌트를 업데이트 할 수 없고, 컴포넌트가 새로운 데이터로 업데이트 되려면 두가지가 필요합니다.

1. 렌더링간에 데이터를 유지합니다.
2. React를 트리거 하여 새로운 데이터로 컴포넌트를 re-render 합니다.

`useState` hook을 통해 이 두가지를 할 수 있습니다.

### 사용법

```javascript
import { useState } from 'react';
...// in component
const [index, setIndex] = useState(0);
```

`index`가 state 변수이고 `setIndex`가 setter 함수가 됩니다. useState 괄호속 값이 state 변수의 초기 값이 됩니다.

```javascript
... //in event handler
setIndex(index + 1);
```

setter함수 내부에 원하는 값을 넣거나, 기존 state 변수 값에 수를 더하거나, 줄이며 값을 변경 할 수 있습니다.

state 변수로 값을 저장할 수 있고,
state setter 함수로 state의 값을 변경하고, react에게 render trigger를 줄 수 있습니다.

### "use" = Hook

use로 시작되는 함수는 hook이라고 불리는 함수 입니다. Hook들은 React가 렌더링 될때만 사용가능한 함수 입니다. hook들은 컴포넌트의 **최상위 레벨**에서만 호출 할 수 있습니다.

### State is isolated and private

state는 컴포넌트의 지역변수로 선언됩니다. 그래서 같은 컴포넌트를 두번 렌더링하면 각자의 state가 독립적으로 존재합니다. 하나의 state가 변경되었다고 다른 컴포넌트의 state도 같이 변경되지 않습니다.

state는 특정 함수의 호출이나 코드의 위치에 얽매이지 않고 화면의 특정 위치에 'local'하게 있습니다.

(11.21 금)

## Render and Commit

> 컴포넌트가 화면에 보여지기 전에 어컴포넌트들은 리액트에 의해 렌더링 됩니다. 해당 단계들을 알아보겠습니다.

- 리액트에서의 랜더링의 의미
- 언제, 왜 리액트가 컴포넌트를 렌더링 하는지
- 컴포넌트가 화면에 보여질때의 단계
- 왜 렌더링할때 항상 DOM update를 생성하지 않는지

React는 간단하게 세 단계로 컴포넌트를 스크린에 나타냅니다.

1. Triggering a render
2. Rendering th component
3. Committing to the DOM

### Step 1: Trigger a render

컴포넌트가 렌더링 될땐 두가지 경우가 있습니다.

1. 초기 렌더링을 할때
2. 컴포넌트나 부모컴포넌트에 업데이트가 발생했을때

**Initial render**

리액트에서 초기렌더링은 `createRoot`를 호출하고, `render` 메소드를 통해 진행됩니다.

```javascript
import Image from "./Image.js";
import { createRoot } from "react-dom/client";

const root = createRoot(document.getElementById("root"));
root.render(<Image />);
```

**Re-renders when state updates**

컴포넌트가 초기렌더링 된 후, state가 변경이 되면 자동으로 렌더링 큐에 들어가서 업데이트 됩니다.

### Step 2: React renders your components

"Rendering"은 리액트가 컴포넌트를 호출하는 것입니다.

이러한 호출은 재귀적입니다. 업데이트된 컴포넌트가 다른 컴포넌트를 반환하면 리액트는 그것또한 렌더링 할것이기 때문입니다. 중첩된 컴포넌트가 없을때까지 진행되고 그 후에 화면에 어떻게 나타낼지 결정됩니다.

렌더링 유의사항

- 동일 인풋, 동일 아웃풋 : 똑같은 input이 있으면 리액트는 동일한 JSX를 반환해야합니다.
- 렌더링은 렌더링만 해야합니다 : 렌더링 전에 존재하는 다른 객체나 변수들을 변경하면 안됩니다.

### Step 3: React commits changes to the DOM

렌더링을 하면 리액트는 DOM을 수정합니다.

- initial render : `appendChild()` DOM API를 사용하여 DOM nodes를 화면에 그려냅니다.
- 그 이후 render : 렌더링 중에 계산을 통해 최소한의 필요한 부분만 DOM이 바뀌도록 합니다.

**리액트는 렌더링간에 차이가 있을때만 DOM node들을 변경합니다.**

### Browser paint

렌더링이 끝난 후 리액트가 DOM을 업데이트 하면 브라우저는 "browser rendring" 이라 불리는 작업, 화면을 repaint를 진행합니다.

<br />

## State as a Snapshot

state는 JS변수와 비슷하게 보이지만, 변수보단 snapshot 같습니다. 기존의 값을 변경해서 state의 값을 설정하는 것이 아니라 re-render의 trigger를 하여 설정합니다.

- state로 re-render의 trigger를 하는 방법
- 언제, 어떻게 state를 업데이트 하는지
- 왜 state는 즉시 업데이트 되지 않는지
- 이벤트 핸들러는 어떻게 state에 접근하는지

### Setting state triggers renders

리액트에선 사용자와 상호작용하는 이벤트(click, typing, etc)를 화면에 나타내려면 state를 업데이트 해야합니다. 따라서 이벤트 핸들러에서 state를 변경하고 리액트가 re-render 됩니다.

### Rendering takes a snapshot in time

렌더링이 리액트가 컴포넌트를 호출한다고 했고, 컴포넌트는 함수입니다. 따라서 렌더링이 발생할때 JSX는 함수를 snapshot처럼 반환합니다. props, 이벤트 핸들러, 변수들까지 전부 렌더링 할때를 기준으로 계산됩니다.

컴포넌트의 메모리인 state는 일반 변수와 다르게 사라지지 않습니다. 컴포넌트가 렌더링되면 그 순간의 state의 모습이 snapshot처럼 전달됩니다.

```javascript
import { useState } from "react";

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}
      >
        +3
      </button>
    </>
  );
}
```

따라서 위와같은 코드에서 버튼을 누를때 `setNumber(number+1)`함수가 3번 호출되어도 state인 number는 항상 0이기 때문에 숫자는 3이 아닌 1씩 증가합니다.

```javascript
import { useState } from "react";

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          alert(number);
        }}
      >
        +5
      </button>
    </>
  );
}
```

위와 같은 코드에서 버튼을 누르면 alert창은 어떻게 보일까요?
처음 클릭한다면 alert창엔 0이 보일것입니다.

click을 통해 state 변수(number)가 업데이트 되었고, 그때 number의 값은 `0`이기 때문에 alert엔 `0`으로 보입니다. update된 number(`5`)는 그 이후 버튼을 클릭해야 alert에 보이게 됩니다.

따라서 state가 업데이트 된 후 그 state를 alert으로 보여주고 싶다면, state값을 변경하는 핸들러와 alert 핸들러를 분리해야 합니다.

<br />

## Queueing a Series of State Updates

- "batching"이 무엇이고, react에서 multiple state update를 어떻게 진행하는지
- 동일한 state 변수에 어떻게 여러 업데이트를 적용하는지

리액트는 event handler에 있는 모든 코드가 끝나기 전까지 state를 업데이트 하거나 UI를 변경하지 않습니다. 그렇기 때문에 triggering이 많이 발생하지 않고 여러 컴포넌트에서 다수의 state가 변경할 수 있게 됩니다. 이것을 **batching** 이라고 하며 react app이 빠르게 실행될 수 있게 해줍니다.

batching을 통해 클릭 같은 여러번 발생될 수 있는 이벤트를 동시에 처리하지 않고 하나씩 개별적으로 처리합니다.

### Updating the same state multiple times before the next render

흔한 경우는 아니지만 동일한 state 변수를 한번에 여러번 변경해야 할 경우가 있을 수 있습니다. 그럴땐 함수를 전달해주면 가능합니다.

```javascript
import { useState } from "react";

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber((n) => n + 1);
          setNumber((n) => n + 1);
          setNumber((n) => n + 1);
        }}
      >
        +3
      </button>
    </>
  );
}
```

`setNumber(n => n + 1)`에서 `(n => n + 1)`가 함수이기 때문에 react가 queue에 추가합니다. useState가 실행되며 `(n => n + 1)` 함수가 실행되기 때문에 n의 값을 확인하고 n에 1씩 더해지게 됩니다.

```javascript
<button
  onClick={() => {
    setNumber(number + 5);
    setNumber((n) => n + 1);
  }}
>
  Increase the number
</button>
```

onClick의 함수를 다음과 같이 바꾸면 number는 6씩 오르게 됩니다. 이번에도 number + 5가 실행된 후 `(n => n + 1)`함수가 실행되기 때문입니다.

```javascript
<button
  onClick={() => {
    setNumber(number + 5);
    setNumber((n) => n + 1);
    setNumber(number + 3);
    setNumber((n) => n + 1);
  }}
>
  Increase the number
</button>
```

onClick 함수가 다음과 같이 바뀐다면 number는 4씩 올라가게 됩니다.

| queued update | n   | returns     |
| ------------- | --- | ----------- |
| replaced `5`  | 0   | `5`         |
| `n => n + 1`  | 5   | `5 + 1 = 6` |
| replaced `3`  | 0   | `3`         |
| `n => n + 1`  | 3   | `3 + 1 = 4` |

### Naming convention

useState에 함수를 넣어 업데이트를 할때 다음과 같이 argument 이름을 지어주는 것이 보편적인 방법입니다.

```javascript
setEnabled((e) => !e);
setLastName((ln) => ln.reverse());
setFriendCount((fc) => fc * 2);
```
