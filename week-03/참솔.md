# Week 03

> **Summary**
>
> - JSX에 `on~`으로 시작하는 prop을 통해 `handle~`로 시작하는 event handler 함수를 전달해서 event 처리
> - Capturing 단계에서 parent의 event handler를 먼저 실행시키려면 `on{EVENT}Capture` 사용
> - Event handler의 argument로 전달되는 event object의
>   - `stopPropagation()`를 호출해서 event propagation 비활성화
>   - `preventDefault()`를 호출해서 browser 기본 동작 비활성화
> - Event handler는 side effect를 실행하기 좋은 위치

## [Responding to Events](https://react.dev/learn/responding-to-events)

- React는 JSX에 event handler를 추가할 수 있는 문법 제공
  ```javascript
  export default function Button() {
    const handleClick = () => {
      alert("You clicked me!");
    };
    return <button onClick={handleClick}>Click me</button>;
  }
  ```
- Event handler는 component 내부에 `handle~`로 시작하는 이름으로 선언하거나, prop으로 받아서 사용 가능
  ```javascript
  export default function Button({ onClick, children }) {
    return <button onClick={onClick}>{children}</button>;
  }
  ```
  - Design system을 사용한다면 component가 style만 포함하고 동작은 정의하지 않는 패턴을 사용하게 됨 (구체적인 동작은 prop을 통해 외부에서 주입)
  - Event handler prop의 이름은 `on~`으로 시작하는 convention을 따름
- HTML tag에 따라 적절한 event handler를 사용해야 함 (e.g. `onClick`은 `<div>` 보다는 `<button>`에 사용하는 것이 적절)

### Event propagation

- React가 제공하는 기본 JSX element들 사이에도 event propagation이 동작함
  - `onScroll`을 제외한 모든 event들은 propagate(또는 bubble) 됨
  - `onScroll`은 직접 추가했을 때만 동작
- Event handler 함수의 argument로 전달되는 event object를 통해 propagation 비활성화
  ```javascript
  function Button({ onClick, children }) {
    const handleClick = (e) => {
      e.stopPropagation();
      onClick();
    };
    return <button onClick={handleClick}>{children}</button>;
  }
  ```
- Capturing 단계에서 event를 처리하려면 `on{EVENT}Capture` prop에 handler를 전달
  ```javascript
  <div onClickCapture={handleClickCapture}>
    <div onClickCapture={() => (/* this runs first */)}>
      <button onClick={(e) => e.stopPropagation()} />
      <button onClick={(e) => e.stopPropagation()} />
    </div>
  </div>
  ```
  - Bubbling은 child에서 parent로 event 전파
  - Parent에서 child로 event가 전파되는 capturing 단계에서, **child보다 parent의 handler를 먼저 실행시킬 때 사용**
- Propagation에 의존하면 handler가 언제, 왜 실행되는지 추적하기 어려워 질 수 있으므로,
  1. Propagation을 비활성화하고 (`e.stopPropagation()`),
  2. 부모로부터 prop으로 handler를 전달받아 직접 실행하는 패턴을 사용할 것을 권장

### Preventing default behavior

- Event handler의 argument로 전달되는 event object의 `preventDefault()`를 호출해서 기본 동작 방지 가능
  ```javascript
  export default function Signup() {
    return (
      <form
        onSubmit={(e) => {
          e.preventDefault();
          alert("Submitting!");
        }}
      >
        <input />
        <button>Send</button>
      </form>
    );
  }
  ```

### Side effects

- Rendering functions와 달리, event handlers는 순수성이 필요 없으므로 side effect를 실행시키기 좋음
- 변경하려는 data는 state로 저장하게 됨

## [State: A Component's Memory](https://react.dev/learn/state-a-components-memory)

> **Summary**
>
> - Component는 서로 다른 render 간에 data를 공유하지 않음
> - Local variable을 변경하고 component를 re-rendering 하면 변경 사항이 반영되지 않음
> - 서로 다른 render 간에 component에 data를 공유하고 변경사항을 유지하려면 **State** 사용
> - `useState` hook을 사용해서 component에 state를 연결
>   - `useState`를 비롯한 React hook은 component 함수의 top-level에서만 호출해야 함
>   - 이 규칙 덕분에 `useState`는 호출 순서에 따라 index로 값을 식별할 수 있고, 간결한 문법 사용 가능
> - State는 component에 격리(isolate)된 private data 이므로, 다른 component와 공유하거나 부모 component에서 접근할 수 없음
> - **다른 component와 동일한 state를 공유하려면, state를 가장 가까운 공통 부모 component로 끌어올려서(Lifting State) prop으로 전달**

### Local variables와 state variables

- React가 interaction의 결과를 화면에 보여주려고 할 때, local variable을 사용하면 동작하지 않는다.
  1. Local variables는 render 간에 유지되지 않고,
  2. Local variables 변경이 rendering을 trigger 하지 않는다. (React가 component가 re-render 되어야 한다는 것을 알지 못한다.)
- Component를 새 data로 갱신하려면,
  1. Render 사이에 data가 유지되어야 하고,
  2. 새 data로 component를 re-render 하도록 trigger 해야 한다.

### useState hook

- Hook : React에서 `use`로 시작하는 rendering 중에만 사용할 수 있는 특별한 함수
  - React의 다른 기능들에 연결(hook into)해 주는 함수
  - Hooks는 components 또는 custom hooks의 top level 에서만 호출해야 한다.
    - Conditions, loops, nested functions 등에서 호출 불가
- `useState(initialValue)`는 React의 state라는 기능에 연결해 주는 hook
  1. Latest state value를 `initialValue`로 초기화
     - 최초 render 시점에 latest value로 설정
     - 이후 re-rendering 될 때는 이미 latest value가 존재하므로 `initialValue`는 무시
  2. Render 간에 data가 유지(retain)되는 **state variable** 제공
  3. Data을 변경헀을 때 이를 React에게 알려서(trigger) component를 re-render 시키는 **setter function** 제공
     - Setter function의 argument로 전달한 값은 다음 render에서 latest state value로 설정
- Array destructuring을 통해 state variable과 setter function을 받는 convention으로 사용
  ```javascript
  import { useState } from "react";
  // ...
  const [index, setIndex] = useState(0);
  ```
- 원하는 state 갯수 만큼 `useState`를 사용
  ```javascript
  import { useState } from "react";
  // ...
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);
  const handleNextClick = () => setIndex(index + 1);
  const handleMoreClick = () => setShowMore(!showMore);
  // ...
  ```
  - 서로 관련 없는 state들은 개별적으로 `useState` 사용
  - 서로 연관되어 비슷한 시점에 변경되는 state들은 객체로 묵어서 하나의 state로 관리하는 것을 권장

### How does React know which state to return?

- React hook은 간결한 syntax를 유지하기 위해 동일한 component에서 hook의 호출 순서에 의존함
  - Hook은 항상 top-level에서 호출해야 한다는 규칙 덕분에, hook들은 항상 동일한 순서로 호출될 수 있음
- React는 component 마다 state pairs array로 state를 관리
  - 최초 pair index는 `0`
  - React는 `useState`를 호출할 때마다 next state pair를 제공하고 index를 증가시킴
  - 참고 : [React hooks: not magic, just arrays](https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e)
- `useState` 내부 동작 예시

  ```javascript
  let componentHooks = [];
  let currentHookIndex = 0;

  function useState(initialState) {
    let pair = componentHooks[currentHookIndex];
    if (pair) {
      // This is not the first render,
      // so the state pair already exists.
      // Return it and prepare for next Hook call.
      currentHookIndex++;
      return pair;
    }

    // This is the first time we're rendering,
    // so create a state pair and store it.
    pair = [initialState, setState];

    function setState(nextState) {
      // When the user requests a state change,
      // put the new value into the pair.
      pair[0] = nextState;
      updateDOM();
    }

    // Store the pair for future renders
    // and prepare for the next Hook call.
    componentHooks[currentHookIndex] = pair;
    currentHookIndex++;
    return pair;
  }
  ```

### State is isolated and private

- State는 component의 local에 저장되므로, 동일한 component가 두 번 render 될 때 각 copy는 완전히 격리(isolate)됨
- 동일한 component를 두 번 render하면, 각 component의 state 변경은 독립적으로 동작함
- Prop과 달리 state는 완전히 private 해서 parent component가 변경할 수 없음
- 독립된 두 component에서 state를 공유하고 싶다면, 각 child component에서 state를 제거하고 가장 가까운 parent component에 state를 추가한 뒤 각 component에 prop으로 전달 -> **Lifting State**
