# Week 03

> **Summary**
>
> - JSX에 `on~`으로 시작하는 prop을 통해 `handle~`로 시작하는 event handler 함수를 전달해서 event 처리
> - Capturing 단계에서 parent의 event handler를 먼저 실행시키려면 `on{EVENT}Capture` 사용
> - Event handler의 argument로 전달되는 event object의
>   - `stopPropagation()`를 호출해서 event propagation 비활성화
>   - `preventDefault()`를 호출해서 browser 기본 동작 비활성화
> - Event handler는 side effect를 실행하기 좋은 위치

## [Responding to Events](https://react.dev/learn/responding-to-events)

- React는 JSX에 event handler를 추가할 수 있는 문법 제공
  ```javascript
  export default function Button() {
    const handleClick = () => {
      alert("You clicked me!");
    };
    return <button onClick={handleClick}>Click me</button>;
  }
  ```
- Event handler는 component 내부에 `handle~`로 시작하는 이름으로 선언하거나, prop으로 받아서 사용 가능
  ```javascript
  export default function Button({ onClick, children }) {
    return <button onClick={onClick}>{children}</button>;
  }
  ```
  - Design system을 사용한다면 component가 style만 포함하고 동작은 정의하지 않는 패턴을 사용하게 됨 (구체적인 동작은 prop을 통해 외부에서 주입)
  - Event handler prop의 이름은 `on~`으로 시작하는 convention을 따름
- HTML tag에 따라 적절한 event handler를 사용해야 함 (e.g. `onClick`은 `<div>` 보다는 `<button>`에 사용하는 것이 적절)

### Event propagation

- React가 제공하는 기본 JSX element들 사이에도 event propagation이 동작함
  - `onScroll`을 제외한 모든 event들은 propagate(또는 bubble) 됨
  - `onScroll`은 직접 추가했을 때만 동작
- Event handler 함수의 argument로 전달되는 event object를 통해 propagation 비활성화
  ```javascript
  function Button({ onClick, children }) {
    const handleClick = (e) => {
      e.stopPropagation();
      onClick();
    };
    return <button onClick={handleClick}>{children}</button>;
  }
  ```
- Capturing 단계에서 event를 처리하려면 `on{EVENT}Capture` prop에 handler를 전달
  ```javascript
  <div onClickCapture={handleClickCapture}>
    <div onClickCapture={() => (/* this runs first */)}>
      <button onClick={(e) => e.stopPropagation()} />
      <button onClick={(e) => e.stopPropagation()} />
    </div>
  </div>
  ```
  - Bubbling은 child에서 parent로 event 전파
  - Parent에서 child로 event가 전파되는 capturing 단계에서, **child보다 parent의 handler를 먼저 실행시킬 때 사용**
- Propagation에 의존하면 handler가 언제, 왜 실행되는지 추적하기 어려워 질 수 있으므로,
  1. Propagation을 비활성화하고 (`e.stopPropagation()`),
  2. 부모로부터 prop으로 handler를 전달받아 직접 실행하는 패턴을 사용할 것을 권장

### Preventing default behavior

- Event handler의 argument로 전달되는 event object의 `preventDefault()`를 호출해서 기본 동작 방지 가능
  ```javascript
  export default function Signup() {
    return (
      <form
        onSubmit={(e) => {
          e.preventDefault();
          alert("Submitting!");
        }}
      >
        <input />
        <button>Send</button>
      </form>
    );
  }
  ```

### Side effects

- Rendering functions와 달리, event handlers는 순수성이 필요 없으므로 side effect를 실행시키기 좋음
- 변경하려는 data는 state로 저장하게 됨

## [State: A Component's Memory](https://react.dev/learn/state-a-components-memory)

> **Summary**
>
> - Component는 서로 다른 render 간에 data를 공유하지 않음
> - Local variable을 변경하고 component를 re-rendering 하면 변경 사항이 반영되지 않음
> - 서로 다른 render 간에 component에 data를 공유하고 변경사항을 유지하려면 **State** 사용
> - `useState` hook을 사용해서 component에 state를 연결
>   - `useState`를 비롯한 React hook은 component 함수의 top-level에서만 호출해야 함
>   - 이 규칙 덕분에 `useState`는 호출 순서에 따라 index로 값을 식별할 수 있고, 간결한 문법 사용 가능
> - State는 component에 격리(isolate)된 private data 이므로, 다른 component와 공유하거나 부모 component에서 접근할 수 없음
> - **다른 component와 동일한 state를 공유하려면, state를 가장 가까운 공통 부모 component로 끌어올려서(Lifting State) prop으로 전달**

### Local variables와 state variables

- React가 interaction의 결과를 화면에 보여주려고 할 때, local variable을 사용하면 동작하지 않는다.
  1. Local variables는 render 간에 유지되지 않고,
  2. Local variables 변경이 rendering을 trigger 하지 않는다. (React가 component가 re-render 되어야 한다는 것을 알지 못한다.)
- Component를 새 data로 갱신하려면,
  1. Render 사이에 data가 유지되어야 하고,
  2. 새 data로 component를 re-render 하도록 trigger 해야 한다.

### useState hook

- Hook : React에서 `use`로 시작하는 rendering 중에만 사용할 수 있는 특별한 함수
  - React의 다른 기능들에 연결(hook into)해 주는 함수
  - Hooks는 components 또는 custom hooks의 top level 에서만 호출해야 한다.
    - Conditions, loops, nested functions 등에서 호출 불가
- `useState(initialValue)`는 React의 state라는 기능에 연결해 주는 hook
  1. Latest state value를 `initialValue`로 초기화
     - 최초 render 시점에 latest value로 설정
     - 이후 re-rendering 될 때는 이미 latest value가 존재하므로 `initialValue`는 무시
  2. Render 간에 data가 유지(retain)되는 **state variable** 제공
  3. Data을 변경헀을 때 이를 React에게 알려서(trigger) component를 re-render 시키는 **setter function** 제공
     - Setter function의 argument로 전달한 값은 다음 render에서 latest state value로 설정
- Array destructuring을 통해 state variable과 setter function을 받는 convention으로 사용
  ```javascript
  import { useState } from "react";
  // ...
  const [index, setIndex] = useState(0);
  ```
- 원하는 state 갯수 만큼 `useState`를 사용
  ```javascript
  import { useState } from "react";
  // ...
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);
  const handleNextClick = () => setIndex(index + 1);
  const handleMoreClick = () => setShowMore(!showMore);
  // ...
  ```
  - 서로 관련 없는 state들은 개별적으로 `useState` 사용
  - 서로 연관되어 비슷한 시점에 변경되는 state들은 객체로 묵어서 하나의 state로 관리하는 것을 권장

### How does React know which state to return?

- React hook은 간결한 syntax를 유지하기 위해 동일한 component에서 hook의 호출 순서에 의존함
  - Hook은 항상 top-level에서 호출해야 한다는 규칙 덕분에, hook들은 항상 동일한 순서로 호출될 수 있음
- React는 component 마다 state pairs array로 state를 관리
  - 최초 pair index는 `0`
  - React는 `useState`를 호출할 때마다 next state pair를 제공하고 index를 증가시킴
  - 참고 : [React hooks: not magic, just arrays](https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e)
- `useState` 내부 동작 예시

  ```javascript
  let componentHooks = [];
  let currentHookIndex = 0;

  function useState(initialState) {
    let pair = componentHooks[currentHookIndex];
    if (pair) {
      // This is not the first render,
      // so the state pair already exists.
      // Return it and prepare for next Hook call.
      currentHookIndex++;
      return pair;
    }

    // This is the first time we're rendering,
    // so create a state pair and store it.
    pair = [initialState, setState];

    function setState(nextState) {
      // When the user requests a state change,
      // put the new value into the pair.
      pair[0] = nextState;
      updateDOM();
    }

    // Store the pair for future renders
    // and prepare for the next Hook call.
    componentHooks[currentHookIndex] = pair;
    currentHookIndex++;
    return pair;
  }
  ```

### State is isolated and private

- State는 component의 local에 저장되므로, 동일한 component가 두 번 render 될 때 각 copy는 완전히 격리(isolate)됨
- 동일한 component를 두 번 render하면, 각 component의 state 변경은 독립적으로 동작함
- Prop과 달리 state는 완전히 private 해서 parent component가 변경할 수 없음
- 독립된 두 component에서 state를 공유하고 싶다면, 각 child component에서 state를 제거하고 가장 가까운 parent component에 state를 추가한 뒤 각 component에 prop으로 전달 -> **Lifting State**

## [Render and Commit](https://react.dev/learn/render-and-commit)

> **Summary**
>
> React는 세 단계에 걸쳐서 UI를 그린다.
>
> 1. Triggering a render : `root.render()` 호출(iniital render) 또는 state 변경(re-renders)
> 2. Rendering the component : component 함수를 호출해서 rendering output 생성
> 3. Committing to the DOM : rendering output을 실제 DOM에 반영

### 1. Triggering a render

Component를 rendering 하는 두 가지 상황

- **Initial render** : App이 시작될 때 `createRoot()`가 반환하는 root 객체의 `render()` method를 호출했을 때
  ```javascript
  import App from "./App";
  import { createRoot } from "react-dom/client";
  const root = createRoot(document.getElementById("root"));
  root.render(<App />);
  ```
- **Re-renders** : `useState` hook이 반환하는 setter function으로 state를 변경했을 때
  - Component의 state를 변경하면 자동으로 render queue에 등록됨

### 2. Rendering the component

- **Initial render** : React가 root component 함수를 호출해서 render
- **Subsequent renders** : React는 state가 변경된 component의 함수를 호출해서 render
- Rendering은 root component부터 시작해서 더 이상 nested components가 없을 때까지 재귀적으로 실행됨
  - React의 기본 rendering 동작은 성능 최적화가 되어있지 않음
  - Tree에서 높이 있는 component가 re-rendering 되면, 하위 component들을 모두 re-rendering
  - 성능 문제가 발생했다면, [Performance](https://reactjs.org/docs/optimizing-performance.html) 문서를 참고해서 최적화를 시작한다.
  - 이 때, **성능 문제가 발생하지 않았는데도 조기에 최적화하지 않는다.**

### 3. Committing to the DOM

- Component 함수가 호출되고 나면, React는 실제 DOM을 변경한다.
- **Initial render** : `appendChild()`를 사용해서 화면에 그려질 DOM node들을 추가한다.
- **Re-renders** : Rendering 과정에서 최신 rendering output과 일치시키기 위한 최소한의 필요한 변경만 수행한다.
  - **두 render 사이에 차이가 발생한 DOM node만 변경**

### Browser paint

- Rendering이 끝나고 React가 DOM을 변경하면 브라우저에서 **repaint** 발생
- Browser rendering 이라고 부르지만, React의 rendering과 구분하기 위해 'repaint'라고 부른다.

## [State as a Snapshot](https://react.dev/learn/state-as-a-snapshot)

> **Summary**
>
> - React는 state를 사용해서 component render마다 props, event handlers 등을 계산해서 UI snapshot(JSX)을 생성
> - State의 setter 함수는 next render에서 state를 변경하는 것이므로, setter 함수 호출 직후 동일한 render 안에서는 state가 변경되지 않음
> - 즉, component에서 state를 사용하면 현재 render 시점의 state 값의 snapshot을 얻는 것
> - 따라서, 현재 state 값으로 next state를 여러 번 계산하더라도 모두 같은 값으로 계산되어 setter 함수를 여러 번 호출하더라도 변화가 없음
> - State 변경 후 `setTimeout` 등 비동기 함수에서 state를 참조하면, 해당 시점의 snapshot을 참조하므로 변경된 state를 사용하지 않음

- State는 일반적인 JavaScript variables 처럼 보이지만, 실제로는 snapshot 처럼 동작
- State는 함수가 반환된 후 사라지는 일반적인 local variables가 아니라, 함수 외부에 존재하는 React가 관리하는 값임
- React가 component를 호출하면 **각 render 마다 state 값을 사용해서 계산된 props, event handlers** 등을 포함하는 UI snapshot(JSX)을 생성
- 이 때, State를 변경하는 것은 next render에만 영향을 미치기 때문에, setter function을 호출한 직후에는 변경된 state 값을 사용할 수 없음
  ```javascript
  import { useState } from "react";
  export default function Counter() {
    const [number, setNumber] = useState(0);
    const handleClick = () => {
      setNumber(number + 1); // 0 + 1
      setNumber(number + 1); // 0 + 1
      setNumber(number + 1); // 0 + 1
    };
    return (
      <>
        <h1>{number}</h1>
        <button onClick={handleClick}>+3</button>
      </>
    );
  }
  ```
  - `setNumber`를 세 번 호출하더라도, `setNumber` 호출 직후에는 여전히 current render임
  - 즉, 각 `setNumber`에서 사용한 `number` state는 변경전 값인 `0`
  - 따라서, 세 번의 `setNumber` 호출은 모두 state를 `1`로 변경하는 것과 같음
- 이것은 `setTimeout` 같은 비동기 함수 내부에서도 동일하게 적용됨
  ```javascript
  const handleClick = () => {
    setNumber(number + 5);
    setTimeout(() => {
      alert(number);
    }, 3000);
  };
  ```
  - 버튼을 클릭하면 `setNumber`가 next render에서 state를 5로 변경하고, 3초 후에 alert을 예약
  - Event handler가 종료되면 re-rendering이 발생하고, next render에서 `number`는 `5`가 되어 render에 반영됨
  - 하지만, 3초 후 실행되는 `setTimeout` callback은 previous render에서의 `number` state 값인 `0`을 참조함
  - `setTimeout` callback은 current render에서의 `number` state 값을 참조하기 때문 -> **closure**
- 즉, **state는 같은 render 안에서는 변경되지 않으므로**, state를 참조하면 해당 시점에 state 값을 snapshot으로 참조하게 됨

## [Queueing a Series of State Updates](https://react.dev/learn/queueing-a-series-of-state-updates)

> **Summary**
>
> - React는 state 변경을 queue에 저장했다가 event handler 실행이 종료된 후 batch update 처리
>   - State를 변경할 때마다 rendering 하지 않으므로 re-render 횟수를 줄여서 app 실행 속도 향상
>   - 현재 render에서 변경하려는 state 중 일부만 변경된 채로 re-render 되는 것을 방지
> - Setter 함수에 값을 전달하면 state를 즉시 변경
> - Setter 함수에 updater function을 전달하면 현재 state 값을 사용해서 next state 값을 계산

- React는 event handler가 종료될 때까지 state 변경을 보류하므로, 여러 개의 state variables를 변경해도 너무 많은 re-render를 trigger 하지 않음
- React는 이렇게 여러 component의 여러 state들을 **batching** 처리해서 app을 더 빠르게 실행 가능하고, state 일부만 변경된 상태로 rendering 되는 것을 방지 (avoids dealing with confusing "half-finished" renders)
  - 단, React는 click 같은 의도적인 event들은 batch 처리하지 않음
  - 일반적으로 안전한 상황에서만 batch 처리를 하도록 보장됨
- State 변경을 batch 처리하기 위해, React는 **state 변경을 즉시 반영하지 않고 queue에 저장**한 뒤 event handler가 종료된 이후 순서대로 일괄 처리함 -> **batch update**
  - `setValue(newValue)` : state를 `newValue`로 즉시 변경하는 코드를 queue
  - `setValue((prev) => nextValue)` : 현재(또는 이전) state를 사용해서 next state를 계산 후 반환하는 **updater function**을 queue
- 이전 section에서 본 것처럼, 동일한 render에서 state variable은 snapshot을 저장하므로 아래와 같은 상황에서는 모든 setter 함수가 동일한 값으로 state를 변경하게 됨
  ```javascript
  const handleClick = () => {
    setNumber(number + 1); // 0 + 1 -> 1
    setNumber(number + 1); // 0 + 1 -> 1
    setNumber(number + 1); // 0 + 1 -> 1
  };
  ```
- 하지만, updater function을 사용한다면 이전에 queue된 함수에서 반환된 값이 state로 설정되어 다음에 queue된 함수의 prev state로 사용되므로 이전에 변경한 값이 반영됨
  ```javascript
  const handleClick = () => {
    setNumber((prev) => prev + 1); // 0 + 1 -> 1
    setNumber((prev) => prev + 1); // 1 + 1 -> 2
    setNumber((prev) => prev + 1); // 2 + 1 -> 3
  };
  ```
- `setNumber(newValue)`와 `setNumber((prev) => nextValue)`를 섞어서 사용하는 경우,
  ```javascript
  const handleClick = () => {
    setNumber(number + 5); // 0 + 5 -> 5
    setNumber((n) => n + 1); // 5 + 1 -> 6
    setNumber(42); // 42
  };
  ```
- 이 때, updater function은 render 중간에 실행되므로 **반드시 pure function** 이어야 하고, next state value를 반환해야 함
  - Updater function 내부에서 side effect를 실행하지 않는다.
  - React의 strict mode는 이런 문제를 개발 모드에서 미리 발견할 수 있도록 updater function을 두 번씩 실행
- Updater function argument의 naming convention
  - **해당 state variable 이름의 첫 글자 조합**
    - `setEnabled` : `(e) => ...`
    - `setLastName` : `(ln) => ...`
    - `setFriendCount` : `(fc) => ...`
  - 좀 더 명확한 이름을 원한다면, state 이름을 그대로 사용하거나 `prev~` previx 추가
    - `setEnabled` : `(enabled) => ...` 또는 `(prevEnabled) => ...`
    - `setLastName` : `(lastName) => ...` 또는 `(prevLastName) => ...`
    - `setFriendCount` : `(friendCount) => ...` 또는 `(prevFriendCount) => ...`
