# Responding to Events

## 이벤트 핸들링

- 보통 핸들러 함수를 사용하는 컴포넌트 내에서 사용한다.
- 핸들러 함수의 이름은 대개 handle + 이벤트명 `(e.x onMouseEnter = {handleMouseEnter})`

```jsx
export default function Button() {
  function handleClick() {
    alert("You clicked me!");
  }

  return <button onClick={handleClick}>Click me</button>;
}

export default function Button() {
  return (
    <button
      onClick={function handleClick() {
        alert("You clicked me!");
      }}
    >
      Click me
    </button>
  );
}

export default function Button() {
  return <button onClick={() => alert("You clicked me!")}>Click me</button>;
}
```

### 함수와 함수 호출 구분하기

함수를 전달할 때 함수 호출을 전달하는 경우가 틀린 것은 아니지만, 이벤트 핸들러 함수를 전달할 때는 함수를 전달해야한다.

이벤트가 일어났을 때 실행 vs 즉시 함수 실행을 잘 생각해보면 바로 이해할 수 있다.

```jsx
function Parent() {
  const getValue = () => {
    console.log("함수 실행");
    return "결과값";
  };

  return <button onClick={getValue()} />;
}

// 인자를 필요로 하는 상황에는 바로 실행될 수 있기에, 고차함수로 감싸서 클릭됐을 때 실행
function Parent() {
  const getValue = (id) => {
    console.log("함수 실행");
    return "결과값";
  };

  return <button onClick={() => getValue(id)} />;
}
```

### props에 접근

```jsx
function AlertButton({ message, children }) {
  return <button onClick={() => alert(message)}>{children}</button>;
}
```

### 부모 -> 자식 핸들러 전달

```jsx
function Button({ onClick, children }) {
  return <button onClick={onClick}>{children}</button>;
}

function PlayButton({ movieName }) {
  function handlePlayClick() {
    alert(`Playing ${movieName}!`);
  }
  return <Button onClick={handlePlayClick}>Play "{movieName}"</Button>;
}
```

### 커스텀 핸들러

```jsx
function Button({ onSmash, children }) {
  return <button onClick={onSmash}>{children}</button>;
}
<Button onSmash={() => alert("Playing!")}>Play Movie</Button>;
```

## event propagation

```jsx
export default function Toolbar() {
  return (
    <div
      className="Toolbar"
      onClick={() => {
        alert("You clicked on the toolbar!");
      }}
    >
      <button onClick={() => alert("Playing!")}>Play Movie</button>
      <button onClick={() => alert("Uploading!")}>Upload Image</button>
    </div>
  );
}
```

- div를 클릭했을 때: 클릭한 div의 핸들러함수만 실행됨
- Play버튼을 클릭했을 때: Play버튼의 핸들러 함수 실행 이후 div의 핸들러함수 실행
- Upload버튼을 클릭했을 때: Upload버튼의 핸들러 함수 실행 이후 div의 핸들러함수 실행

이러한 현상이 생기는 이유는 이벤트 버블링(이벤트 전파) 때문이다. 이벤트가 발생한 지점에서부터 트리를 따라서 위로 전파된다.

React내의 모든 이벤트는 `onScroll`을 제외하고 전파된다.

### stopPropagation

이벤트 객체의 stopPropagation을 사용하면 이벤트 전파를 멈출 수 있다.

```jsx
function Button({ onClick, children }) {
  return (
    <button
      onClick={(e) => {
        e.stopPropagation();
        onClick();
      }}
    >
      {children}
    </button>
  );
}

export default function Toolbar() {
  return (
    <div
      className="Toolbar"
      onClick={() => {
        alert("You clicked on the toolbar!");
      }}
    >
      <Button onClick={() => alert("Playing!")}>Play Movie</Button>
      <Button onClick={() => alert("Uploading!")}>Upload Image</Button>
    </div>
  );
}
```

### preventDefault

몇몇 이벤트들은 기본동작이 발생한다. 가장 대표적으로 `form` 태그의 onSubmit 이벤트는 새로고침 이라는 기본 동작을 발생 시킨다.

이벤트 객체의 preventDefault를 사용하면 기본 동작을 막을 수 있다.

> 자세한 내용
>
> [MDN: preventDefault()](https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
>
> [MDN: Event Cancelable](https://developer.mozilla.org/en-US/docs/Web/API/Event/cancelable)

```jsx
export default function Signup() {
  return (
    <form
      onSubmit={(e) => {
        e.preventDefault();
        alert("Submitting!");
      }}
    >
      <input />
      <button>Send</button>
    </form>
  );
}
```

# State: A Component's Memory

## state

State는 컴포넌트가 기억하는 정보이다. 일반 변수를 사용해서 기억한다 하더라도, 이 데이터가 변경되었을 때 리렌더링이 일어나지 않는다. 정확히는 렌더링 사이에 데이터가 유지되지 않는다. 동적인 UI를 구현하여 리렌더링을 유발하고, 렌더링 간에 값을 유지하기 위해서 State를 사용한다.

다시 말하면, 컴포넌트를 리렌더링 하기 위해서는

- 렌더링 사이에 데이터를 유지 -> `state`
- React가 데이터의 변경을 감지하도록 하기 -> `state setter`

## state

예시 `useState`

```jsx
import { useState } from "react";
import { sculptureList } from "./data.js";

export default function Gallery() {
  const [index, setIndex] = useState(0);

  function handleClick() {
    setIndex(index + 1); // setter로 데이터 변경
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleClick}>Next</button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <img src={sculpture.url} alt={sculpture.alt} />
      <p>{sculpture.description}</p>
    </>
  );
}
```

```jsx
// useState 문법
const [state, setIndex] = useState(초기값);

const [index, setIndex] = useState(0);
```

## 여러 state를 선언할 때

```jsx
const [index, setIndex] = useState(0);
const [showMore, setShowMore] = useState(false);
```

연관되어 있지 않은 데이터들은 각자 state로 분리, 자주 함께 변경되는 값은 객체로 합치기를 고려해보는 것도 좋다.

## isolated, private

```jsx
import Gallery from "./Gallery.js";

export default function Page() {
  return (
    <div className="Page">
      <Gallery />
      <Gallery />
    </div>
  );
}
```

같은 컴포넌트를 여러 번 렌더링하면 각 컴포넌트마다 isolated state를 가진다.

다시 말해, 하나의 컴포넌트에서 state를 변경해도 다른 컴포넌트에는 영향이 없다.

State는 선언한 컴포넌트에만 비공개로 존재하며, 부모는 자식 state를 구조적으로는 변경하거나 알 수 없다.

## state 배열

리액트는 렌더링이 시작될 때, 해당 컴포넌트의 훅(state) 배열을 이용해 상태값을 관리한다.

렌더링 과정에서 컴포넌트가 useState 등을 호출할 때마다, 배열의 현재 인덱스(커서) 위치를 기준으로 값을 읽고, 각 useState 호출 시마다 커서 값을 1씩 증가시키면서, 배열에서 순서대로 값을 반환한다. (0→1→2… 순서로)

만약 state를 변경하면, 해당 인덱스 위치의 값이 새로 저장됩니다.

그리고 매 렌더링이 끝나면, 다음 렌더링 전에 커서를 다시 0으로 초기화한다.

React의 state가 closure의 개념과 연관되어 있는데, 뒤 챕터에 있는 것 같아서 그때 한번 제대로 정리해볼 수 있으면 좋을 것 같다.

> [자세히](https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e)

# Render and Commit

UI를 그리는 과정

1. Trigger: Render를 유발하는, Render 호출
2. Render: 컴포넌트를 계산하고 그리기
3. Commit: 최종적으로 DOM에 반영

## Trigger

컴포넌트가 최초 렌더링되거나, state가 변경될 때 렌더링을 trigger한다.

개인적으로는 trigger는 렌더를 유발하는 하나의 신호라고 정리를 하면 좋을 것 같고, 그 신호를 주는 조건들이 최초 렌더링을 할 때와 state의 변경이고, `얘네가 렌더링을 trigger한다` 라고 정리

## Render

최초 렌더링을 하는 경우

```jsx
import { createRoot } from "react-dom/client";
import App from "./App";

const root = createRoot(document.getElementById("root")); // root 생성
root.render(<App />); // render 호출
```

state가 변경되는 경우(리 렌더링 경우): state의 상태가 업데이트되면, 업데이트가 일어난 컴포넌트를 호출하고, 연결된 컴포넌트들을 모두 호출한다. (recursive)

## Commit

Render과정에서는 어떻게 렌더링을할 지 `계산`이 이루어지는 과정이고 실제 DOM에 반영하는 과정을 Commit이라고 한다.

최초 렌더링의 경우에는 appendChild라는 브라우저 API를 통해서 트리에 순차적으로 자식 노드를 붙인다.

리렌더링의 경우에는 최초 렌더링과는 다르게 기존 노드를 변경하거나 새로운 노드를 추가한다.

## 레이아웃과 페인팅

레이아웃: 브라우저가 화면에 그릴 때 각 DOM요소의 위치, 크기 등 큰 틀을 정하는 과정

페인팅: 정해진 레이아웃의 구체적인 부분(색, 테두리, 글자 등)을 픽셀 단위로 그려서 실제로 보여지도록 그리는 과정

레이아웃 -> 페인팅 구조로, 레이아웃 과정이 일어나면 페인팅 과정도 일어난다.

# State as a Snapshot

리액트의 state 변수는 실제로는 스냅샷과 비슷하게 동작한다.

state를 변경해도 곧바로 값이 바뀌는 것이 아니라, 리렌더링이 예약되고, 새로운 값은 다음 렌더에서 반영된다. -> 해당 렌더링에 대한 state의 스냅샷을 이용한다.

또, state는 선언한 컴포넌트 외부에 저장되고, 각 렌더링마다의 스냅샷을 내부에 제공하는 것이다.

```jsx
export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}
      >
        +3
      </button>
    </>
  );
}
```

예를 들어, 여기서 number가 클릭하자마자 바로 업데이트 되는 것이 아니라, 사실 클릭한 시점에는 0으로 기억하고 있기 때문에 아래와 같이 동작한다

```jsx
setNumber(0 + 1);
setNumber(0 + 1);
setNumber(0 + 1);
```

아래 코드에서도 화면상 number가 렌더링되고 약 3초뒤에 alert창이 뜨지만, alert창의 number는 클릭할 당시의 number를 띄운다.

```jsx
export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5);
          setTimeout(() => {
            alert(number);
          }, 3000);
        }}
      >
        +5
      </button>
    </>
  );
}
```

정리하면, 상태 변경은 새로운 렌더링을 예약하는 것이지 해당 렌더링에서 즉시 바뀌지는 않는다.

# Queueing a Series of State Updates

React는 state를 즉시 변경하지 않고, 다음 렌더링을 위해 업데이트를 업데이트 큐에 저장한다. 이를 한 번에 모아서 업데이트를 처리하는 작업을 `batching`이라고 한다.

예를 들어 이벤트 핸들러가 실행될 때 여러 번 set 함수가 호출되어도 렌더링은 한 번만 발생한다.

## updater function

이벤트 핸들러 내부에서 여러번 업데이트 하고 싶을 때는 updater 함수를 사용한다.

```jsx
export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}
      >
        +3
      </button>
    </>
  );
}
```

```jsx
export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber((prev) => prev + 1);
          setNumber((prev) => prev + 1);
          setNumber((prev) => prev + 1);
        }}
      >
        +3
      </button>
    </>
  );
}
```

업데이트 큐에 값`(number+1)`을 넣는 것이 아닌 함수 객체(`prev=>prev+1`)룰 전달하고, 각 함수가 업데이트된 값을 받아서 누적 계산하는 원리이다. 값을 전달할 때는 누적 계산하는 것이 아닌 큐의 마지막 값으로 업데이트한다.

> [링크](https://github.com/sprint18-4-4/Coworkers/discussions/32#discussioncomment-14914432)
