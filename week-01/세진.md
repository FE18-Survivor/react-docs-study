# Week 01 (11.04)

## Your First Component

> 컴포넌트는 리액트의 핵심 요소 중 하나입니다. <br>
> 컴포넌트를 통해 재사용가능한 UI를 만들 수 있습니다.

### Defining a component

리액트는 기존의 방식(HTML + JS)과 유사하게 컴포넌트를 만들 수 있습니다.

<ol>
<li>export 접두사 작성하기 (export는 js의 문법이다)</li>
<li>js함수를 정의하기 (이때 함수의 첫글자는 대문자여야 한다)</li>
<li>JSX문법으로 HTML을 작성하여 반환하기</li>
</ol>

컴포넌트는 HTML 처럼 사용할 수 있습니다. e.g.`<Profile />`

### What the browser sees

전부 소문자인 태그는 HTML로 판단하지만, 앞글자가 대문자라면 컴포넌트로 인식합니다. 따라서 컴포넌트를 만들때엔 무조건 대문자로 함수를 정의해야 합니다.

### Nesting and organizing components

컴포넌트는 JS 함수이기 때문에, 한 파일에 여러개의 컴포넌트가 있어도 괜찮습니다. 관계가 밀접하거나, 크기가 작은 컴포넌트의 경우에 특히 유용합니다. 반대로 파일이 복잡해질 경우 분리할 수도 있습니다. 컴포넌트는 항상 독립적으로 생성되어야 하며, 컴포넌트 안에서 다른 컴포넌트를 "생성"할수는 없습니다.

---

## Importing and Exporting Components

> - 한 파일에서 export, import를 할 수 있습니다.
> - root component도 export를 합니다.
> - 한 파일에서 default export는 하나만 할 수 있습니다.
> - 이미 default export가 있다면, named export로 다른 함수도 export 할 수 있습니다.
> - named export는 {}와 함께 import 구문을 작성해야합니다.

---

## Writing Markup with JSX

> JSX는 JS 파일 안에서 "HTML 같은" 마크업을 작성할 수 있게 해주는 JS 확장 문법입니다.

### JSX: Putting markup into JavaScript

예전엔 HTML, CSS, JS가 각각 다른 파일에서 관리되어왔지만, Web의 상호작용이 커짐에 따라 로직을 담당하는 JS에 HTML 구문들이 증가하기 시작했습니다. 따라서 리액트에선, 컴포넌트를 통해 렌더링 로직과 마크업이 동일한 위치에 존재합니다.

렌더링 로직과 마크업이 같이 있으면, 편집과정에서 서로 동기화 됩니다. 상관없는 렌더링 로직과 마크업은 분리가 되어 안전하게 관리할 수 있습니다.

### The Rules of JSX

JSX는 "HTML 같은" 마크업이라고 했습니다. HTML과 유사하지만 차이점이 있기 때문입니다. HTML 보다 조금 더 엄격한 규칙을 따릅니다.

1. 하나의 태그만 반환되어야 합니다. (하나의 부모 태그를 가져야 합니다)

```JSX
❌
return (
  <h1>Title </h1>
  <p>detail content</p>
)

✅
return (
  <div>
    <h1>Title </h1>
    <p>detail content</p>
  </div>
)
```

`<div>`를 늘리고 싶지 않다면 Fragment태그를 사용할 수도 있습니다.

```JSX
return (
  <>
    <h1>Title </h1>
    <p>detail content</p>
  </>
)
```

2. 모든 태그는 닫혀야 합니다.

```HTML
❌
return (
  <>
    <ul>
      <li>Invent new traffic lights
      <li>Rehearse a movie scene
      <li>Improve the spectrum technology
    </ul>
  </>
)

✅
return (
  <>
    <ul>
      <li>Invent new traffic lights</li>
      <li>Rehearse a movie scene</li>
      <li>Improve the spectrum technology</li>
    </ul>
  </>
)
```

3. 대부분 camelCase로 작성되어야 합니다.

```
stroke-width -> strokeWidth
class -> className
```

**_JSX는 왜 HTML과 다를까요?_**

(1)번의 경우

JSX는 작성하기엔 HTML과 유사해 보이지만, JS 객체로 변환됩니다. 1번 예시의 잘못된 return처럼 tag가 2개라면, 2개의 객체로 변하게 됩니다. 따라서 복수의 객체를 배열로 변환해야 하기 때문에 부모 태그가 필요합니다.

(3)번의 경우

JSX에서 작성된 속성(attribute)은 JS 객체의 키가 됩니다. 속성을 변수로 활용해야 할 때가 많은데, JS에서는 변수의 이름에 하이픈(-)이 들어갈 수 없고, `class`같은 예약어가 들어갈 수 없습니다. 따라서 `camelCase`로 적거나, 예약어와 동일할 경우 일부 변경되어 사용됩니다.

**_JSX to JS_**

1. Parsing:
   트랜스파일러(예: Babel)가 JSX 코드를 스캔하여 그 구조와 요소를 분석합니다.

2. AST 생성:
   파싱된 JSX는 추상 구문 트리(Abstract Syntax Tree, AST) 로 변환됩니다. AST는 코드 구조를 트리 형태로 표현한 것입니다.

3. Code Transformation:
   AST를 변환하여 JSX 요소들이 표준 자바스크립트 함수 호출로 바뀝니다.

```javascript
<h1 className="greeting">Hello</h1>;

React.createElement("h1", { className: "greeting" }, "Hello");
```

4. Code Generation: 변환된 AST를 이용해 브라우저가 이해하고 실행할 수 있는 표준 자바스크립트 코드가 생성됩니다.

---

(11.07.금)

## JavaScript in JSX with Curly Braces

> JSX를 통해 HTML"같은" 마크업을 사용할 수 있습니다. 마크업을 작성할때 변수나, 작은 로직을 추가하고 싶을때 중괄호({})를 통해 해결할 수 있습니다.

### Where to use curly braces

1. 텍스트처럼

```javascript
<h1>hello, {name}! </h1>
```

2. 속성처럼

```javascript
<img src={logoImg} />
```

### Using “double curlies”: CSS and other objects in JSX

object를 전달하거나, css의 스타일 속성을 inline으로 적고 싶을땐 중괄호로 두번 감싸면 됩니다.

- CSS의 예

```javascript
<ul
  style={{
    backgroundColor: "black",
    color: "pink",
  }}
>
  ...
</ul>
```

css를 inline 스타일로 작성할 경우, style의 properties는 `camelCase`로 작성되어야 합니다.

- object의 예

```javascript
const person = {
  name: "Gregorio Y. Zara",
  theme: {
    backgroundColor: "black",
    color: "pink",
  },
};

export default function TodoList() {
  return (
    <div style={person.theme}>
      <h1>{person.name}'s Todos</h1>
      <img className="avatar" src="https://i.imgur.com/7vQD0fPs.jpg" alt="Gregorio Y. Zara" />
      <ul>
        <li>Improve the videophone</li>
        <li>Prepare aeronautics lectures</li>
        <li>Work on the alcohol-fuelled engine</li>
      </ul>
    </div>
  );
}
```
