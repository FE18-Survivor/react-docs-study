# Week 09

## [Removing Effect Dependencies](https://react.dev/learn/removing-effect-dependencies)

- React linter는 Effect에서 사용한 모든 reactive value들을 dependencies list에 포함시켰는지 확인해서, **Effect가 component의 최신 props 및 state와 동기화**되도록 함
- 하지만, 불필요한 dependencies는 Effect를 너무 자주 실행시키거나 무한 루프에 빠지게 하므로 제거해야 함
- 어떤 변수를 dependencies list에서 제거하려면, **이 변수가 Effect에서 dependency로 필요하지 않다는 것을 증명(prove)**해야 함
  - 이 변수의 값이 reactive 하지 않고 re-renders 중에 변경되지 않는다는 것을 증명
  - Dependencies list에는 Effect에서 사용하는 모든 reactive values가 포함되어야 하므로,
  - 반대로 **Effect 내부에서 해당 dependency를 사용하는 logic을 제거**하면 dependencies list에서도 제거할 수 있음
- 불필요한 dependency를 제거하는 방법
  1. 특정 interaction이 발생했을 때 실행되어야 하는 logic은 event handler로 이동
  2. 관련 없는 여러 개의 logic을 독립된 다른 Effect로 분리
     - 각 Effect는 independent synchronization process를 나타내야 함
  3. State variable을 직접 사용하는 대신 updater function 내부에서 접근
  4. Non-reactive logic을 Effect 밖으로 추출
     - React 19.2 에서 도입된 `useEffectEvent` hook 사용
     - 이 때, non-reactive logic이 reactive values를 사용하고 있었다면, 해당 변수를 dependencies list에서 제거 가능
  5. Object 및 functions를 component 외부 또는 Effect 내부로 이동
     - Object 및 functions는 component 내부에서 선언하면 매 렌더링마다 새로 생성되며 서로 다른 객체로 인식하기 때문
     - Static object 및 functions는 component 밖으로 이동
     - Dynamic object 및 functions는 Effect 내부로 이동
  6. Object 및 functions를 Effect 밖에서 읽고, 실제로 사용할 primitive value만 Effect에서 사용 (dependencies list에 포함)
     - **Object 또는 function이 dependencies list에 포함되지 않아야 함**

## [Reusing Logic with Custom Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)

- Fetching data, tracking online status, connecting to a chat room 등 특별한 목적을 가진 hook을 직접 만들어서 여러 component에서 재사용 할 수 있음
  - **State 자체가 아닌 stateful logic을 공유**
- Custom hook은 '어떻게 동작하는지(how to do)'보다 '무엇을 하는지(what they want to do)'을 나타내야 함
  - 사용자가 online 상태인지 나타내는 로직을 여러 component에서 사용하려는 경우,
  - "Online 상태를 사용한다(use an online status)"는 동작을 나타내야 함
  - "Browser event를 구독한다"는 구체적인 동작 방식을 나타내지 않음
  - 이렇게 만들면 **component 코드가 구현이 아닌 의도를 나타내게 됨**
- Custom hook의 naming conventions
  - `use`로 시작하고, JSX가 아닌 임의의 값을 반환
  - 이 convention은 **내부에서 React built-in hook을 사용한다는 것을 나타내어** component의 state나 effect가 어디에 있는지 알 수 있게 함
  - React linter는 이 convention을 적용한 custom hook과 component 에서만 다른 hook을 호출할 수 있도록 강제
  - Hook을 사용하지 않는 코드는 custom hook으로 만들 필요 없음. 즉, **hook convention을 따르지 않는 함수는 내부에서 custom hook을 사용하지 않으므로 rendering 중에 호출하지 않아도 됨**
- Custom hook을 만들어야 하는 경우
  - 모든 중복 코드를 custom hook으로 추출할 필요는 없음 (e.g. `useState` 1개만 사용하는 경우)
  - Effect는 여러 동기화 logic을 다른 Effect로 분리해서 장황해 질 수 있으므로, custom hook으로 wrapping 하면 더 간결하고 의도가 명확해 질 수 있음
- Custom hook을 **고수준 use case**를 나타내도록 만들기
  - Custom hook 이름은 이 hook이 무엇을 하는지 쉽게 유추할 수 있게 만들어야 함
    - `useDate(url)`, `useImpressionLog(eventName, extraData)`, `useChatRoom(options)` 등
    - `useMediaQuery(query)`, `useSocket(url)`, `useIntersectionObserver(ref, options)` 등
  - Custom hook 이름을 결정하기 어렵다면, hook 내부에 너무 많은 logic이 엉켜 있는 것일 수 있음
  - **`useEffect` API를 대체하는 custom lifecycle을 갖는 wrapper로 만들지 않는다.**
    - `useMount(fn)`, `useEffectOnce(fn)`, `useUpdateEffect(fn)` 등
  - **좋은 custom hook은 code가 하는 일을 제한하여 code 호출을 더 선언적으로 만들어 줌**
    - `useChatRoom`, `useImpressionLog` 등은 각각 한 가지 일만 하도록 제한됨
    - 이런 제약이 없이 너무 추상화되면 장기적으로 유지보수가 어려워질 수 있음

### Custom Hooks help you migrate to better patterns

- React 팀의 목표는 specific problem을 위한 specific solutions를 제공하여 app 내의 Effect 갯수를 최대한 줄이는 것
- Effect를 custom hook으로 wrapping 하면 React에서 solution이 사용 가능해 졌을 때 code를 upgrade 하기 쉬워짐
- Effect를 custom hook으로 wrapping 하는 것의 장점
  1. Effect의 data flow를 분명하게 알 수 있음
  2. Components에서 Effect의 구체적인 구현은 숨기고 의도만 드러낼 수 있음
  3. React에 새로운 feature가 추가될 때, component를 수정하지 않고 Effect를 수정/삭제할 수 있음
