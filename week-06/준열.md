<h2>6주차 첫 번째</h2> 

<h3>시작하며...</h3>

- 각 컴포넌트는 독립된 State를 가진다.
  
- React는 UI 트리에서의 위치를 통해 각 State가 어떤 컴포넌트에 속하는지 추적한다.
  
- 리렌더링마다 언제 State를 보존하고 초기화할지 컨트롤할 수 있다.

<h3>State는 어떻게 렌더트리의 위치에 연결될까?</h3>

- React는 UI 안의 컴포넌트 구조를 기반으로 렌더 트리를 만든다.
  
- 컴포넌트 안에서 `useState`를 호출하면, `state` 값은 `컴포넌트 내부`가 아니라 React `내부의 state 저장소`에 따로 저장된다.

- 컴포넌트는 `어떤 컴포넌트의 State인지에 대한 Key값`만 갖게된다.

- React는 렌더 시 컴포넌트와 hook의 호출 순서를 기준으로 각 state를 저장소의 올바른 슬롯에 연결한다. 즉, `“렌더 트리의 위치 + hook 호출 순서”`로 state를 매칭하는 구조이다.

> 그렇기에 hook은 항상 같은 순서로 호출되어야하는 규칙이 있는 것이다!

<h3>그렇다면 컴포넌트가 언마운트되면 State는 어떻게 제거가 될까?</h3>

- React에는 Fiber Node라는 구조가 컴포넌트마다 존재한다.

- 각 Fiber Node가 그 컴포넌트의 state 저장 슬롯 목록을 갖고 있다.

- 언마운트시 Fiber Node가 제거되면서, 연결되어있던 State 슬롯도 같이 제거된다.

<h3>같은 위치의 동일한 컴포넌트는 State를 보존한다</h3>

- React는 컴포넌트를 렌더 트리의 특정 위치(Fiber Node)로 관리한다.
  
- 같은 자리에 같은 컴포넌트가 다시 렌더되면, React는 기존 Fiber Node를 재사용한다.
  
- Fiber Node가 유지되는 경우, 그 Node에 연결된 state 저장 슬롯도 그대로 보존된다.
  
- 따라서 화면에서 사라진 것처럼 보여도 “언마운트되지 않았다면” State는 유지된다.

<h3>같은 위치의 다른 컴포넌트는 State를 초기화한다</h3>

- React는 컴포넌트의 타입(예: A vs B)에 따라 서로 다른 Fiber Node를 생성한다.
  
- 같은 자리에 다른 컴포넌트가 오면, 기존 Fiber Node는 폐기되고 새로운 Node가 생성된다.
  
- 새로운 Fiber Node에는 기존 State 슬롯이 없기 때문에 모든 State는 초기값으로 다시 생성된다.
  
- 즉, **Fiber Node가 변경되면 State도 완전히 초기화된다.**

<h3>같은 위치에서 State를 초기화하는 방법</h3>

```javascript
import { useState } from 'react';

export default function Scoreboard() {
  const [isPlayerA, setIsPlayerA] = useState(true);
  return (
    <div>
      {isPlayerA ? (
        <Counter person="Taylor" />
      ) : (
        <Counter person="Sarah" />
      )}
      <button onClick={() => {
        setIsPlayerA(!isPlayerA);
      }}>
        Next player!
      </button>
    </div>
  );
}
// Next player! 이라는 버튼을 클릭하면, 플레이어가 바뀌지만 점수는 유지되는 코드 일부
```

<h4>1) 다른 위치에서 컴포넌트를 렌더링한다.</h4>

```javascript
import { useState } from 'react';

export default function Scoreboard() {
  const [isPlayerA, setIsPlayerA] = useState(true);
  return (
    <div>
      {isPlayerA &&
        <Counter person="Taylor" />
      }
      {!isPlayerA &&
        <Counter person="Sarah" />
      }
      <button onClick={() => {
        setIsPlayerA(!isPlayerA);
      }}>
        Next player!
      </button>
    </div>
  );
}
// 적은 수의 독립된 컴포넌트만 가지고 있을 때 편한 방법
// Next player! 버튼을 누를때마다 DOM에서 컴포넌트가 제거되어 State가 초기화된다.
```
<h4>2) key를 이용해 State를 초기화한다.</h4>

```javascript
import { useState } from 'react';

export default function Scoreboard() {
  const [isPlayerA, setIsPlayerA] = useState(true);
  return (
    <div>
      {isPlayerA ? (
        <Counter key="Taylor" person="Taylor" />
      ) : (
        <Counter key="Sarah" person="Sarah" />
      )}
      <button onClick={() => {
        setIsPlayerA(!isPlayerA);
      }}>
        Next player!
      </button>
    </div>
  );
}
// 배열을 렌더링할때와 동일하게 key값을 다르게 지정해 state의 공유를 막을 수 있다.
```

> key가 전역적으로 유일하지 않다는 것을 기억해야 합니다. key는 오직 부모 안에서만 자리를 명시합니다.

<h4>2-1)key를 이용해 form을 초기화하기</h4>

```javascript
import { useState } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';

export default function Messenger() {
  const [to, setTo] = useState(contacts[0]);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedContact={to}
        onSelect={contact => setTo(contact)}
      />
      <Chat contact={to} />
      {/* <Chat id={to.id} contact={to} */}
    </div>
  )
}

const contacts = [
  { id: 0, name: 'Taylor', email: 'taylor@mail.com' },
  { id: 1, name: 'Alice', email: 'alice@mail.com' },
  { id: 2, name: 'Bob', email: 'bob@mail.com' }
];

// contacts의 id값 속성을 이용하여 state를 초기화하여 메세지 입력칸을 비운다.
```

<h3>제거된 컴포넌트의 State를 보존하기</h3>

- 컴포넌트가 언마운트되면 해당 Fiber Node가 제거되며 연결된 State도 함께 사라진다.
- 하지만 UX 요구에 따라 “보이지 않는 컴포넌트의 State를 유지해야 하는” 상황도 존재한다.
- 이러한 경우 아래와 같은 몇 가지 접근을 사용할 수 있다.

<h4>1) 컴포넌트를 언마운트하지 않고 숨기기</h4>

- 특정 컴포넌트를 조건부 렌더링으로 제거하는 대신, 항상 렌더링시키고 CSS로만 감춘다.
- 렌더 트리에서 사라지지 않기 때문에 Fiber Node가 유지되고 기존 State도 그대로 보존된다.
- 단, 숨겨진 내용이 많아 DOM이 커지면 성능 문제가 발생할 수 있다.

<h4>2) State를 상위 컴포넌트로 끌어올리기 (Lifting State Up)</h4>

- 자식 컴포넌트를 제거해도 데이터가 유지되어야 한다면 부모 컴포넌트가 State를 관리하게 한다.
- 자식은 props를 통해 State를 렌더링할 뿐이므로 언마운트되더라도 데이터는 남아 있게 된다.
- 여러 조건부 UI에서 가장 보편적으로 사용되는 방식이다.

<h4>3) React 외부 저장소 사용하기</h4>

- 사용자가 페이지를 닫아도 데이터를 유지하고 싶다면 localStorage 같은 외부 저장소를 활용할 수 있다.
- 저장된 값을 기반으로 Chat(혹은 특정 UI)을 다시 초기화할 수 있다.
