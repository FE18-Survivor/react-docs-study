# Week 06

## [Preserving and Resetting State](https://react.dev/learn/preserving-and-resetting-state)

> **Summary**
>
> - React는 component가 re-render 될 때 동일한 위치(position)에 있는 동일한 component에 대해 state를 보존(preserve)함
>   - 동일한 위치(position) : JSX 코드가 아닌 render tree 상에서 component의 위치
>   - 동일한 component : component의 종류 (e.g. `<div>`)
> - 즉, 동일한 위치에 동일한 component가 render 될 때는 state가 초기화되지 않고 이전 render에서의 state 값을 유지함
> - 따라서, 동일한 위치에 동일한 component를 render 할 때 state는 초기화하고 싶다면
>   - Component가 rendering되는 각 조건 별로 JSX를 구성해서 render tree에서 다른 위치를 갖도록 만들거나,
>   - Component에 `key`를 설정해서 React가 다른 component로 인식하게 만든다.

---

- React는 UI를 구성하는 component들로 render tree를 생성함
- Component에서 정의하는 state는 component가 아닌 React에 속해 있음
- React는 **component가 render tree로 만들어질 때 state를 해당하는 component로 연결**
- 즉, **동일한 위치에 render되는 동일한 component에 대해 state를 보존(preserve)**함
  - 위치(position)는 JSX 코드가 아닌 UI를 그리는 **render tree(or UI tree) 상에서의 위치**를 기준으로 함
  - Component가 re-render 되어도 state를 유지하려면, 두 render에 대한 tree 구조가 동일해야 함
  - 이전 render에서 존재하던 어떤 component에 대해 위치 또는 component 종류가 바뀌면 React는 관련된 state를 초기화한다.
- 아래 코드에서 `counter` 변수는 동일한 component 객체를 참조하지만 render tree 상에서 다른 위치에 존재하므로 각각 **독립적인 state를 가지고** 독립적으로 동작함

  ```javascript
  import { useState } from 'react';

  export default function App() {
    const counter = <Counter />;
    return (
      <div>
        {counter}
        {counter}
      </div>
    );
  }

  function Counter() {
    const [score, setScore] = useState(0);
    const [hover, setHover] = useState(false);

    return (...);
  }
  ```

- 아래와 같이 조건부로 렌더링하는 component는 state가 매번 초기화되는 것을 확인할 수 있음
  ```javascript
  function App() {
    const [showB, setShowB] = useState(true);
    return (
      <div>
        <Counter />
        {showB && <Counter />}
        <label>
          <input
            type="checkbox"
            checked={showB}
            onChange={(e) => setShowB(e.target.checked)}
          />
          Render the second counter
        </label>
      </div>
    );
  }
  ```
- 아래와 같이 다른 props를 넘겨서 서로 다른 component 객체를 생성하더라도, **동일한 위치에 동일한 component라면 state가 보존됨**
  ```javascript
  function App() {
    const [isFancy, setIsFancy] = useState(false);
    return (
      <div>
        {isFancy ? <Counter isFancy={true} /> : <Counter isFancy={false} />}
        <label>
          <input
            type="checkbox"
            checked={isFancy}
            onChange={(e) => setIsFancy(e.target.checked)}
          />
          Render the second counter
        </label>
      </div>
    );
  }
  ```
- 이 규칙을 활용하면 render tree 상에서 동일한 위치에 동일한 component를 render 할 때 state를 초기화 할 수 있음
  - React는 동일한 위치에서 "동일한 component"를 render 할 때 state를 보존하므로, 아래 코드에서 player를 변경해도 score state값이 유지됨
    ```javascript
    export default function Scoreboard() {
      const [isPlayerA, setIsPlayerA] = useState(true);
      return (
        <div>
          {isPlayerA ? <Counter person="Taylor" /> : <Counter person="Sarah" />}
          <button
            onClick={() => {
              setIsPlayerA(!isPlayerA);
            }}
          >
            Next player!
          </button>
        </div>
      );
    }
    ```
  - 따라서, 둘 중 하나의 조건을 만족하지 않게 만들면 state를 초기화 할 수 있음
  - **Component가 다른 위치에 render 되도록 만들거나,**
    ```javascript
    export default function Scoreboard() {
      const [isPlayerA, setIsPlayerA] = useState(true);
      return (
        <div>
          {isPlayerA && <Counter person="Taylor" />}
          {!isPlayerA && <Counter person="Sarah" />}
          <button
            onClick={() => {
              setIsPlayerA(!isPlayerA);
            }}
          >
            Next player!
          </button>
        </div>
      );
    }
    ```
  - **`key`를 사용해서 다른 component로 인식되도록 만들 수 있음**
    ```javascript
    export default function Scoreboard() {
      const [isPlayerA, setIsPlayerA] = useState(true);
      return (
        <div>
          {isPlayerA ? (
            <Counter key="Taylor" person="Taylor" />
          ) : (
            <Counter key="Sarah" person="Sarah" />
          )}
          <button
            onClick={() => {
              setIsPlayerA(!isPlayerA);
            }}
          >
            Next player!
          </button>
        </div>
      );
    }
    ```
    - List를 rendering 할 때 `key`를 사용할 때와 같은 원리
    - `key`를 사용하면 React가 component 위치를 결정할 때 순서(order) 대신 `key`를 사용함

## [Extracting State Logic into a Reducer](https://react.dev/learn/extracting-state-logic-into-a-reducer)

> **Summary**
>
> - `useState` 대신 `useReducer`를 사용하면 component 함수 외부에 reducer 함수로 state update logic을 분리해서 component 코드를 더 간결하게 만들 수 있다.
> - `useState`를 사용하는 것 보다 코드는 많아지지만 debugging 및 testing에 유리하다.
> - Reducer 함수는 rendering 중에 실행되므로 반드시 순수 함수여야 한다.
> - `dispatch()`로 전달하는 action 객체는 하나의 user interaction만 나타낸다.
> - 'Immer' 라이브러리를 사용하면 `useState`를 `useImmer`로 대체한 것처럼, `useReducer`를 `useImmerReducer`로 대체해서 객체 state 변경을 쉽게 처리할 수 있다.

---

- Component 복잡도가 올라갈수록 state logic이 얽혀서 어떤 경로로 변경되는지 파악하기 어려움
- State logic의 복잡도를 낮추고 쉽게 접근할 수 있도록 하기 위해, component 함수 바깥의 "reducer" 함수로 state logic을 옮길 수 있음

  - Reducer : component 내부 코드를 줄여주는(reduce) 역할
  - Array의 `reduce()` method에 전달하는 'reducer' 함수가 current item과 result로 next result를 계산하는 것과 비슷한 개념
  - React의 reducer는 current state와 action으로 next state를 계산하는 역할

    ```javascript
    function tasksReducer(tasks, action) { ... }

    let initialState = [];
    let actions = [
      { type: "added", id: 1, text: "Learn React" },
      // ...
    ];
    let finalState = actions.reduce(taskReducer, initialState);
    ```

- Reducer로 관심사를 분리해서(separate concerns) component logic을 이해하기 쉽게 만들 수 있다.
- `useState`를 `useReducer`로 migration

  1. 코드를 'setting state'에서 'dispatching actions'로 변경

     ```javascript
     // Before
     function handleAddTask(text) {
       setTasks([
         ...tasks,
         {
           id: nextId++,
           text: text,
           done: false,
         },
       ]);
     }

     // After
     function handleAddTask(text) {
       dispatch({
         type: "added",
         id: nextId++,
         text: text,
       });
     }
     ```

     - 'Action'은 일반적인 JavaScript 객체
     - Component 관련 추가 정보를 `type` field에 명시하는 convention 사용 (e.g. `"added"`, `"added_task"`)

  2. Reducer function 작성
     ```javascript
     function tasksReducer(tasks, action) {
       switch (action.type) {
         case "added": {
           return [
             ...tasks,
             {
               id: action.id,
               text: action.text,
               done: false,
             },
           ];
         }
         case "changed": {
           return tasks.map((t) => {
             if (t.id === action.task.id) {
               return action.task;
             } else {
               return t;
             }
           });
         }
         case "deleted": {
           return tasks.filter((t) => t.id !== action.id);
         }
         default: {
           throw Error("Unknown action: " + action.type);
         }
       }
     }
     ```
     - 첫 번쨰 argument : current state
       - current state를 argument로 받기 때문에 reducer를 component 밖에 선언 가능
     - 두 번째 argument : `dispatch()`에 전달한 action 객체
     - 반환값 : next state
       - React가 reducer의 반환값을 state 값으로 설정함
       - `if`/`else`문 대신 `switch`문을 사용해서 action을 분기하는 convention 사용
  3. Component에서 `useState` 대신 `useReducer` 사용

     ```javascript
     // before
     const [tasks, setTasks] = useState(initialTasks);

     // after
     const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);
     ```

### Comparing `useState` and `useReducer`

- `useReducer`는 `useState`보다 더 많은 코드를 작성해야 하지만(reducer function 및 dispatch actions), 여러 event handler들이 비슷한 패턴으로 state를 변경하는 코드를 줄일 수 있다.
- State 변경 코드가 복잡해질 때, `useReducer`는 event handler에서 state update logic이 어떻게 실행되는지 `useState`보다 더 명확하게 구분할 수 있다.
- `useState`는 버그가 발생했을 때 state를 어디서 잘못 변경했는지 추적하기 어렵지만, `useReducer`는 버그를 발생시킨 action을 통해 문제가 발생한 logic을 쉽게 찾을 수 있다.
- Reducer는 순수 함수이므로 component에 의존하지 않아서 독립적으로 테스트하기 쉽다.
- `useReducer`는 state를 잘못 변경해서 버그가 자주 발생하는 component에서 사용하는 것을 권장한다.
  - 모든 곳에 reducer를 사용할 필요는 없다.
  - `useState`와 `useReducer`는 상호 교체해서 사용해도 되고, 같은 component 안에서 같이 사용해도 된다.

### Writing reducers well

- **Reducer는 순수 함수여야 한다.**
  - State updater function과 같이 **reducer는 rendering 중에 실행**되므로 순수 함수여야한다.
  - 동일한 input에 대해 항상 동일한 output을 반환해야 한다.
  - 외부 상태(external state)를 변경하지 않아야 한다.
- 각 action은 하나의 user interaction만 나타내야 한다.
- 'Immer' 라이브러리를 사용하면 `useImmerReducer` hook을 사용해서 객체 state를 쉽게 변경할 수 있다.
  ```javascript
  function tasksReducer(draft, action) {
    switch (action.type) {
      case "added": {
        draft.push({
          id: action.id,
          text: action.text,
          done: false,
        });
        break;
      }
      case "changed": {
        const index = draft.findIndex((t) => t.id === action.task.id);
        draft[index] = action.task;
        break;
      }
      case "deleted": {
        return draft.filter((t) => t.id !== action.id);
      }
      default: {
        throw Error("Unknown action: " + action.type);
      }
    }
  }
  ```
  - Reducer 첫 번째 argument로 state가 아닌 `draft`를 전달
  - Reducer 내부에서는 `draft`를 직접 변경

## [Passing Data Deeply with Context](https://react.dev/learn/passing-data-deeply-with-context)

> **Summary**
>
> - Props drilling : UI tree의 깊은 곳에 있는 component에서 data를 사용할 수 있도록 props를 통해 전달하는 것
> - Context를 사용하면 props drilling 문제를 해결하고, 여러 component들이 동일한 data를 사용하는 경우 쉽게 전달할 수 있다.
> - Context를 사용하기 전에 아래 두 가지 방법을 먼저 고려해 본다.
>   1. Data를 prop으로 전달해서 data 흐름 및 어떤 component가 해당 data를 사용하는지 분명하게 나타내는 것이 더 좋은가?
>   2. Data를 실제로 사용하지 않는 component가 단순히 data를 전달하기 위해 prop을 갖는 경우, 실제로 data를 사용하는 component를 함수로 추출해서 해결할 수 있는가?

- Props로 data를 전달할 때, data를 필요로 하는 component가 UI tree에서 깊은 곳에 있거나 여러 component들이 동일한 data(prop)를 사용하는 경우 "prop drilling" 문제가 발생할 수 있다.
- 'Context'는 parent component에서 하위 tree 전체에 data를 제공(provide)해서 이 문제를 해결한다.
  - 아래와 같이 `Heading` component에 `level` prop을 일일이 전달하는 대신,
    ```javascript
    export default function Page() {
      return (
        <Section>
          <Heading level={1}>Title</Heading>
          <Section>
            <Heading level={2}>Heading</Heading>
            <Heading level={2}>Heading</Heading>
            <Section>
              <Heading level={3}>Sub-heading</Heading>
              <Heading level={3}>Sub-heading</Heading>
              <Section>
                <Heading level={4}>Sub-sub-heading</Heading>
                <Heading level={4}>Sub-sub-heading</Heading>
              </Section>
            </Section>
          </Section>
        </Section>
      );
    }
    ```
  - Parent component인 `Section`에 `level` prop을 한 번만 전달해서 하위의 `Heading` component가 `level` 값을 사용할 수 있다면 좋을 것
    ```javascript
    <Section level={3}>
      <Heading>About</Heading>
      <Heading>Photos</Heading>
      <Heading>Videos</Heading>
    </Section>
    ```
  - 이렇게 동작하려면 child component가 상위 tree에 있는 임의의 component에 data를 요청할 수 있어야 함
- Context를 사용하는 방법

  1. Context 생성 : `createContext()` 함수로 생성

     ```javascript
     import { createContext } from "react";

     const LevelContext = createContext(1); // default value '1'
     ```

  2. Child component에서 `useContext(context)` hook을 통해 context value 사용

     ```javascript
     import { useContext } from "react";
     import { LevelContext } from "./LevelContext.js";

     function Heading({ children }) {
       const level = useContext(LevelContext);
       // ...
     }
     ```

  3. Context value를 사용하는 component들위 상위 계층에서 context 제공

     ```javascript
     import { LevelContext } from "./LevelContext.js";

     export default function Section({ level, children }) {
       return (
         <section className="section">
           <LevelContext value={level}>{children}</LevelContext>
         </section>
       );
     }
     ```

- `createContext()`로 생성한 각 context들은 완전히 독립적으로 동작하므로, context가 중첩되어도 override 하지 않는다.
- Context를 사용하기 전에 고려해 볼 것들
  - Props로 전달하는 것 부터 시작하기
    - Component가 간단하지 않다면 prop을 사용해서 component가 어떤 data를 사용하게 되는지 명시적으로 흐름을 나타내는게 좋을 수 있다.
  - Component를 추출해서 `children` prop으로 JSX 전달하기
    - 실제로 사용하지 않는 data를 prop으로 받는 component가 있다면, 해당 data를 실제로 사용하는 component를 추출한다.
    - e.g. `<Layout posts={posts} />` -> `<Layout><Posts posts={posts} /></Layout>`
  - **위 두 가지 방법 모두 사용하기 어렵다면 context를 사용하는 것을 고려한다.**
- Use cases
  - Theming : app root에서 현재 설정된 theme 제공
  - Current account : 현재 로그인한 사용자 정보 제공
  - Routing : 대부분의 routing solutions는 현재 route를 기억하기 위해 context를 사용

## [Scaling Up with Reducer and Context](https://react.dev/learn/scaling-up-with-reducer-and-context)
