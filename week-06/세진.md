# Week 06

(25.12.09)

## Preserving and Resetting State

- 리액트가 언제 state를 유지하고, 초기화 하는지
- 어떻게 state를 강제로 초기화 할 수 있는지
- key와 type이 state의 보존여부에 어떻게 영향을 주는지

### State is tied to a position in the render tree

state는 컴포넌트에 각각 독립적으로 존재하는 것처럼 보입니다. 하지만 state는 컴포넌트 안에 있는게 아니라 리액트에 속해있고 render tree를 기준으로 컴포넌트와 state가 연결됩니다.

컴포넌트가 렌더링이 멈추면 state도 사라집니다. 리액트가 컴포넌트를 지우면서, 연결된 state도 없애기 때문입니다.

리액트는 컴포넌트가 UI 트리에 있을때엔 state를 유지합니다.

### State를 관리하는 방법

#### 1. Preserve

동일한 컴포넌트가 똑같은 자리에 render되면 state는 유지(preserve)됩니다.
<br /> `checkbox`나 `button`으로 컴포넌트의 스타일링이 변화되고 props 값이 변화되어도, `UI tree`에서 컴포넌트는 동일한 **position**에 있다면 state는 없어지지 않습니다.

유의사항 : `JSX`에서 동일한 위치가 아니라 UI tree에서 동일한 위치입니다. `if`를 통해서 `isChecked`같은 변수의 값에 따라 화면에 render 되는것이 달라도, 같은 컴포넌트라면 UI tree에선 변화가 없기 때문에 state가 유지됩니다.

#### 2. Reset

같은 자리에 다른 컴포넌트가 위치하게 되면 state는 초기화(reset)됩니다.
<br />
컴포넌트가 변화하게 되면 UI tree에서 변화가 생깁니다.

`if`에서 `isChecked`가 true이면 `<p>`를, false이면 `<div>`를 return 한다고 하면 상황에 따라 다른 컴포넌트가 반환되게 됩니다. 그러면 컴포넌트는 지워지고, 그와 연결된 state도 없어지기 때문에 초기화가 됩니다.

또한 컴포넌트가 바뀌면 그 하위에 있는 모든 state들도 초기화 됩니다.

따라서 re-render가 될때도 state가 유지(preserve)되려면 UI tree 구조가 **"match up"** 되어야 합니다.

유의사항 : 따라서 state를 prserve 하고 싶으면 nested component는 지양하는것이 좋습니다. 부모 컴포넌트가 버튼 클릭 등의 이벤트가 발생해서 re-render가 되면, 그 안의 _중첩된_ 자식 컴포넌트는 늘 새로 만들어지며, 리액트는 해당 컴포넌트를 _다른_ 컴포넌트로 인식하기 때문입니다.

### Resetting state at the same position

동일한 위치에 state를 재설정 하는 방법은 두가지가 있습니다.

1. 컴포넌트를 다른 위치에 rendering 하기
2. 각각의 컴포넌트에 `key`를 주기

아래는 아직 state가 유지되는 코드입니다.

```javascript
import { useState } from "react";

export default function Scoreboard() {
  const [isPlayerA, setIsPlayerA] = useState(true);
  return (
    <div>
      {isPlayerA ? <Counter person="Taylor" /> : <Counter person="Sarah" />}
      <button
        onClick={() => {
          setIsPlayerA(!isPlayerA);
        }}
      >
        Next player!
      </button>
    </div>
  );
}
```

#### 컴포넌트를 다른위치에 rendering 하기

```javascript
export default function Scoreboard() {
  const [isPlayerA, setIsPlayerA] = useState(true);
  return (
    <div>
      {isPlayerA && <Counter person="Taylor" />}
      {!isPlayerA && <Counter person="Sarah" />}
      <button
        onClick={() => {
          setIsPlayerA(!isPlayerA);
        }}
      >
        Next player!
      </button>
    </div>
  );
}
```

`isPlayerA`의 값이 처음엔 true이기에 첫번째 Counter가 렌더링되고 두번째는 비어있게 됩니다. false로 바뀌면 첫번째가 비어있고, 두번째에 Counter 컴포넌트가 렌더링 됩니다.

#### 각각의 컴포넌트에 key 주기

```javascript
export default function Scoreboard() {
  const [isPlayerA, setIsPlayerA] = useState(true);
  return (
    <div>
      {isPlayerA ? (
        <Counter key="Taylor" person="Taylor" />
      ) : (
        <Counter key="Sarah" person="Sarah" />
      )}
      <button
        onClick={() => {
          setIsPlayerA(!isPlayerA);
        }}
      >
        Next player!
      </button>
    </div>
  );
}
```

좀 더 대중적으로 쓰이는 방식으로, 컴포넌트를 구분하기 위해 `key` 속성을 사용하면 됩니다.

`key`를 특정시키면 key가 position의 일부가 됩니다. key를 통해 JSX에선 동일한 위치에 있는것처럼 보여도 두개의 다른 counter를 가진것처럼 보이게 할 수 있고 state를 구분할 수 있게 됩니다.

- [Form component](https://react.dev/learn/preserving-and-resetting-state#resetting-a-form-with-a-key)

form을 활용할때도 동일하게 key를 사용하여 state를 구분할 수 있습니다.

<br />

## Extracting State Logic into a Reducer

- Reducer function 이란
- `useState`를 `useReducer`로 refactor 하는 방법
- 언제 reducer를 사용해야 하는지
- 어떻게 써야 잘 사용하는건지

### Consolidate state logic with a reducer

reducer를 적용하기 위한 3가지 단계는 다음과 같습니다.

1. Move from setting state to dispatching actions.
2. Write a reducer function.
3. Use the reducer from your component.

useState를 사용하던 기존 코드를 분리하고, reducer function에 맞추어 `action`을 설정해준 뒤, 기존 component에 `useState`대신 `useReducer`를 사용하면 됩니다.

#### 1. Move from setting state to dispatching actions.

기존에 setter 함수를 사용했던 함수를 dispatch를 활용하여 변경합니다. 이때 `type` 키워드가 reduce함수에서 어떤 동작을 할것인지 key 역할을 하게 됩니다. 변경해야 하는 값도 같이 객체에 담아서 보내줍니다. 이를 `action` object 라고 합니다.

```javascript
function handleAddTask(text) {
  setTasks([
    ...tasks,
    {
      id: nextId++,
      text: text,
      done: false,
    },
  ]);
}

//refactor
function handleAddTask(text) {
  dispatch({
    type: "added",
    id: nextId++,
    text: text,
  });
}
```

#### 2. Write a reducer function

기존의 setter 함수가 했던 logic을 수행할 reduce 함수를 작성합니다.

```javascript
function yourReducer(state: variable, action: object) {
  // return next state for React to set
}
```

첫번째 인자로 state를 받고, 두번째 인자로 action 객체를 받아서 작성합니다. 이를 통해 컴포넌트 외부에서 reduce 함수를 작성할 수 있고 코드를 읽기 간편하게 할 수 있게 됩니다.

reduce 함수는 switch문으로 작성하는것이 일반적입니다. case별로 {}로 감싸는 것을 추천하고, `return`문을 통해 끝내는 것을 권장합니다. return이 없으면 다음 case로 이동하게됩니다.

- **reduce라고 불리는 이유**

reduce는 코드의 양을 줄여서 그렇게 붙여진것이 아니라, array 함수 reduce() 연산에서 오게 되었습니다. reduce() 연산이 지금까지의 누적 합과 항목을 받아서 다음 결과를 반환하는것과 동일하게, reducer가 state와 action을 받아서 그 다음 state를 반환하기 때문에 이런 이름이 붙여졌습니다.

#### 3. Use the reducer from your component

- useReducer를 import 합니다.
- useState를 활용했던 state를 useReducer로 변경합니다.

```javascript
const [tasks, dispatch] = useReducer(tasksReducer, initialTasks); //(function, initialStates)
```

- [before refactor 예문](https://react.dev/learn/extracting-state-logic-into-a-reducer#consolidate-state-logic-with-a-reducer)
- [after refactor 예문](https://react.dev/learn/extracting-state-logic-into-a-reducer#step-3-use-the-reducer-from-your-component)

### Comparing useState and useReducer

useReduce도 단점이 있습니다. 두가지를 놓고 비교할때 여러 사항을 고려하면 좋습니다.

- Code size: 초반엔 useState를 사용하는것이 훨씬 편하고 짧을 수 있지만 만약 많은 event handler가 비슷하게 state를 수정한다면 useReducer가 더 좋을 수 있습니다.

- Readability: 컴포넌트가 복잡해지면 useState만을 사용했을때 읽기 어려워집니다. useReducer를 통해 무엇이 발생했는지(event handler), 무엇을 업데이트하는지(logic) 구분할 수 있습니다.

- Debugging: useReducer에 `console.log`를 추가하여 어느 action에서 문제가 발생했는지 파악할 수 있습니다. 다만 useState를 사용할때보다 더 많은 코드가 필요합니다.

- Testing: 컴포넌트에 의존하지 않은 순수함수이기 때문에 함수만 독립적으로 테스트할 수 있습니다. 복잡한 상황에서 특정 상황, 특정 초기값을 넣고 테스트 하는데 유용할 수 있습니다.

- Personal preference

### Writing reducers well

- Reducers는 순수함수여야 합니다. reducer는 렌더링중에 동작합니다. 따라서 동일 입력 동일 출력이 보장되어야 하고, side-effect가 발생되어서는 안됩니다.
- 다수의 변화가 발생되어도 각각의 액션은 하나의 상호작용만 나타내야 합니다. 사용자가 reset버튼을 눌렀을때 5개의 field가 초기화 되어도 5개가 각각 분리되는것이 아니라 reset_form 하나로 동작되는것이 더 좋습니다.

### [Writing concise reducers with Immer](https://react.dev/learn/extracting-state-logic-into-a-reducer#writing-concise-reducers-with-immer)

Immer 라이브러리를 사용할 수도 있습니다.

Immer는 state의 복사본인 draft객체를 제공합니다.

해당 객체를 활용해 state를 mutate 하는것처럼 활용할 수 있습니다.

따라서 `useImmerReducer`를 활용하면 첫번째 인자로 state를 넘겨주지 않아도 되고, case의 return값을 적어주지 않아도 됩니다.

 <br />

## Passing Data Deeply with Context

react에선 props를 통해 information을 전달할 수 있지만, 너무 많은 tree를 거쳐 전달하는 `prop drilling`이 발생할 수도 있습니다. 그럴때 사용할 수 있는것이 `context` 입니다.

### Context를 통해 props를 전달하는 방법

1. Create: context를 만듭니다.

```javascript
//LevelContext.js
import { createContext } from "react";

export const LevelContext = createContext(1);
```

2. Use: 전달받을 data가 필요한 컴포넌트에 context를 작성합니다.

```javascript
//Heading.js
import { useContext } from "react";
import { LevelContext } from "./LevelContext.js";

export default function Heading({ children }) {
  const level = useContext(LevelContext);
  // ...
}
```

3. Provide: data를 전달할 컴포넌트에서 context에 data를 입력합니다.

```javascript
//section.js
import { LevelContext } from "./LevelContext.js";

export default function Section({ level, children }) {
  return (
    <section className="section">
      <LevelContext value={level}>
        {children}
      </LevelContext>
    </section>
  );
}
```

section 컴포넌트에서 children을 LevelContext로 감싸줍니다.
이렇게 해서 section 컴포넌트의 모든 자식 컴포넌트들은 `LevelContext`를 전부 활용할 수 있게 됩니다.

만약 context에 전달할 value를 지정하지 않는다면, createContext에서 작성한 defaultValue를 기준으로 context가 적용됩니다.

context는 css의 상속처럼 부모 컴포넌트에서 제공한 value가 자식 컴포넌트에 상속됩니다. 또한 css별 속성이 서로 영향을 주지 않듯이, `createContext()`로 만들어진 context도 서로에게 영향을 주지않고 독립적으로 사용할 수 있습니다.

### context 사용 전 유의사항

1. props로 먼저 전달해보세요. props로 data를 전달하는것이 흐름을 파악하고 유지보수하기에 편리합니다.
2. 컴포넌트를 분리해보세요. prop drilling이 발생한다면 컴포넌트를 나눌 수 있는지 생각해보세요.

### context를 사용하기 좋은 상황

1. Theming: dark mode등의 테마가 변경될때 app 상단에 context provider를 설정하면 쉽게 적용할 수 있습니다.
2. Current account: 현재 접속한 사용자가 누구인지 파악하고 그 값을 전달하기 위해 사용하기 좋습니다.
3. Routing
4. Managing state : 여러 state가 상단에 있고 하단의 컴포넌트에 전달을 할때, reducer와 context를 사용하면 좋습니다.


## [Scaling Up with Reducer and Context](https://react.dev/learn/scaling-up-with-reducer-and-context)

reducer를 통해 state를 관리할때 `dispatch`는 가장 상위의 컴포넌트에서만 접근이 가능합니다. 다른 하위 컴포넌트에서 state를 변경하려면 dispatch를 props로 전달해야합니다. 이 경우에 context를 사용해서 쉽게 관리할 수 있습니다.

1. Create the context.
2. Put state and dispatch into context.
3. Use context anywhere in the tree.

```javascript
import { TasksContext, TasksDispatchContext } from './TasksContext.js';

export default function TaskApp() {
  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);
  // ...
  return (
    <TasksContext value={tasks}>
      <TasksDispatchContext value={dispatch}>
          <AddTask />
          <TaskList />
      </TasksDispatchContext>
    </TasksContext>
  );
}
```

```javascript
export default function TaskList() {
  const tasks = useContext(TasksContext);
  // ...
```

```javascript
export default function AddTask() {
  const [text, setText] = useState('');
  const dispatch = useContext(TasksDispatchContext);
  // ...
  return (
    // ...
    <button onClick={() => {
      setText('');
      dispatch({
        type: 'added',
        id: nextId++,
        text: text,
      });
    }}>Add</button>
    // ...
```

[예제 전문](https://react.dev/learn/scaling-up-with-reducer-and-context#step-3-use-context-anywhere-in-the-tree)

<br />

### Moving all wiring into a single file

context provider와 reducer를 한 파일에서 관리할 수도 있습니다.

```javascript
//TasksContext.js
import { createContext, useReducer } from 'react';

export const TasksContext = createContext(null);
export const TasksDispatchContext = createContext(null);

export function TasksProvider({ children }) {
  const [tasks, dispatch] = useReducer(
    tasksReducer,
    initialTasks
  );

  return (
    <TasksContext value={tasks}>
      <TasksDispatchContext value={dispatch}>
        {children}
      </TasksDispatchContext>
    </TasksContext>
  );
}

function tasksReducer(tasks, action) {
  switch (action.type) {
    case 'added': {
      return [...tasks, {
        id: action.id,
        text: action.text,
        done: false
      }];
    }
    ...
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}

const initialTasks = [
  { id: 0, text: 'Philosopher’s Path', done: true },
  { id: 1, text: 'Visit the temple', done: false },
  { id: 2, text: 'Drink matcha', done: false }
];
```

reducer로 관리할 state와 필요한 defaultValue, dispatch, context를 하나의 파일로 관리하고 상위 컴포넌트에선 provider 컴포넌트 내부에 자식 컴포넌트를 배치하여 전달합니다.

또한, useContext함수를 provider 컴포넌트에서 export 하여, 자식 컴포넌트에선 함수만 import 하여 사용할 수 있습니다. 동작에 변화는 없지만 컨텍스트를 분할하거나 로직을 추가하기 편합니다.

```javascript
//provider component
export function useTasks() {
  return useContext(TasksContext);
}

export function useTasksDispatch() {
  return useContext(TasksDispatchContext);
}

//sub component
const tasks = useTasks();
const dispatch = useTasksDispatch();
```