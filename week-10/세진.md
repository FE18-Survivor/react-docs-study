# Week10: React Compiler

## Introduction
> React Compiler는 자동으로 React app을 최적화 시켜주는 새로운 build-time tool 입니다. javascript로 동작하며 react 규칙을 이해하기에, react compiler를 사용하기 위해 새로운 코드를 작성할 필요가 없습니다.

### 무엇을 하나요?
React Compiler는 React app이 빌드할때 자동으로 최적화를 해줍니다. 리액트는 최적화 없이 충분히 빠르지만, 종종 수동으로 memoization된 컴포넌트나 value가 있을때, 이들이 관리하기 어렵고 잘못되기 쉬운데 이를 자동으로 최적화 시켜줍니다.

**before React Compiler**

```javascript
import { useMemo, useCallback, memo } from 'react';

const ExpensiveComponent = memo(function ExpensiveComponent({ data, onClick }) {
  const processedData = useMemo(() => {
    return expensiveProcessing(data);
  }, [data]);

  const handleClick = useCallback((item) => {
    onClick(item.id);
  }, [onClick]);

  return (
    <div>
      {processedData.map(item => (
        <Item key={item.id} onClick={() => handleClick(item)} />
      ))}
    </div>
  );
});
```

`<Item key={item.id} onClick={() => handleClick(item)} />` 구문은 memoization을 벗어나는 미묘한 버그가 발생합니다.

handleClick이 useCallback으로 감싸여져 있지만 arrow function이 컴포넌트가 re-render 될때마다 항상 new function을 생성합니다. 이는 즉 Item이 항상 새로운 onClick prop을 받는다는 뜻입니다.

**After React Compiler**

```javascript
function ExpensiveComponent({ data, onClick }) {
  const processedData = expensiveProcessing(data);

  const handleClick = (item) => {
    onClick(item.id);
  };

  return (
    <div>
      {processedData.map(item => (
        <Item key={item.id} onClick={() => handleClick(item)} />
      ))}
    </div>
  );
}

```

#### React Compiler가 추가한 memoization은 무엇을 하나요?
React Compiler의 memoization은 update의 향상에 집중합니다. 따라서 아래 두가지 용례를 볼 수 있습니다.

1. Skipping cascading re-rendering of components

Optimizing Re-renders: React Compiler가 자동으로 manual memoization을 적용하여 state가 바뀔때, 관련있는 부분만 re-render되도록 합니다.

2. Skipping expensive calculations from outside of React

Expensive calculations also get memozied: 렌더링 중에 비용이 높은 연산도 자동으로 memoization할 수 있습니다. 그러나 정말 비용이 많이드는 연산이라면, React 외부에서 자체적으로 memoization을 실행하는것을 고려해봐야 합니다.

왜냐하면 

1. React Compiler는 모든 함수가 아니라, React components와 hooks만 memoizes 합니다.
2. React Compiler의 memoization은 여러 컴포넌트와 hook 사이에 공유되지 않습니다.

따라서 다양한 컴포넌트에서 사용되거나, 동일한 값이 넘겨지더라도, 반복해서 연산이 실행될 것입니다. 따라서 코드가 복잡해지기전에 profiling 하는것을 추천합니다.

### What build tools are supported?
React Compiler는 Babel, Vite, Metro, Rsbuild 등 여러 빌드 도구에 설치 할 수 있습니다.

### What should I do about useMemo, useCallback, and React.memo?
기본적으로 React Compiler가 memoization한 코드가 직접 작성한 코드와 비슷하거나 그보다 더 정확하겠지만, 상황에 따라 개발자가 직접 memoization을 컨트롤 해야 할 수 있습니다. 

새로 작성하는 코드의 경우, memoization은 컴파일러에 맡기고, 정밀한 제어가 필요한 경우에만 `useMemo`나 `useCallback`을 사용하는 것을 권장합니다.

기존 코드의 경우에는, 기존에 작성된 memoization을 유지하거나, 제거하기전에 신중하게 테스트할 것을 권장합니다.


## Incremental Adoption
### 왜 점진적 도입일까요?
React Compiler가 코드전체를 자동으로 최적화되도록 만들어졌지만, 이를 한번에 적용할 필요는 없습니다. 조금씩 적용해가며 컴파일러의 작은 부분부터 테스트해가며 적용할 수 있습니다.

점진적으로 도입하며
1. 컴파일된 코드가 어떻게 동작하는지 정확하게 확인하고
2. 퍼포먼스 향상을 측정하고
3. 엣지 케이스를 특정지을 수 있습니다.
4. React 규칙 위반을 컴파일러가 쉽게 처리할 수 있게 합니다.
5. 또한, 어떤 코드를 컴파일 할것인지 컨트롤 해서, 컴파일러 최적화의 실제 효과를 측정하기 위한 A/B 테스트를 실행할 수도 있습니다.

### Approaches to Incremental Adoption
1. Babel overrides - 특정 경로에 컴파일러를 적용합니다.
2. Opt-in with "use memo" - use memo를 통해 명시적으로 opt in한 컴포넌트만 컴파일 합니다.
3. Runtime gating - feature flag를 통해 컴파일을 컨트롤 합니다.

- opt-in (option in): 사용자가 명시적으로 동의한 것. 선동의 후 사용

### Directory-Based Adoption with Babel Overrides 
Babel의 `overrides` 옵션은 각각의 파트에 다른 플러그인들을 적용할 수 있게 해줍니다.

```javascript
// babel.config.js
module.exports = {
  plugins: [
    // Global plugins that apply to all files
  ],
  overrides: [
    {
      test: './src/modern/**/*.{js,jsx,ts,tsx}',
      plugins: [
        'babel-plugin-react-compiler'
      ]
    }
  ]
};
```

`ovderrides` 옵션에 디렉토리 별로 설정할 수 있습니다.

- [추가 예시](https://react.dev/learn/react-compiler/incremental-adoption#expanding-coverage)

### Opt-in Mode with “use memo” 
```javascript
// babel.config.js
module.exports = {
  plugins: [
    ['babel-plugin-react-compiler', {
      compilationMode: 'annotation',
    }],
  ],
};
```

```javascript
function TodoList({ todos }) {
  "use memo"; // Opt this component into compilation

  const sortedTodos = todos.slice().sort();

  return (
    <ul>
      {sortedTodos.map(todo => (
        <TodoItem key={todo.id} todo={todo} />
      ))}
    </ul>
  );
}

```

1. `compilationMode: 'annotation'`을 추가합니다.
2. 컴파일을 원하는 function의 시작에 `"use memo"`를 추가합니다.

해당 방식을 사용한다면
- optimize를 원하는 모든 컴포넌트에 "use memo"를 적어야 합니다.
- 모든 custom hook에 "use memo"를 적어야 합니다.
- 새로운 컴포넌트에도 작성해야 합니다.

### Runtime Feature Flags with Gating
`gating`옵션은 feature flag를 통해 런타임을 할때 컴파일을 컨트롤할 수 있게 합니다.

#### How Gating Works 
1. 컴파일러는 최적화된 코드를 런타임 체크로 감쌉니다.
2. gate가 true를 반환하면 최적화된 버전이 실행되고,
3. 그렇지 않으면 원래 코드가 실행됩니다.

#### Gating Configuration
```javascript
// babel.config.js
module.exports = {
  plugins: [
    ['babel-plugin-react-compiler', {
      gating: {
        source: 'ReactCompilerFeatureFlags',
        importSpecifierName: 'isCompilerEnabled',
      },
    }],
  ],
};
```

#### Implementing the Feature Flag 
```javascript
// ReactCompilerFeatureFlags.js
export function isCompilerEnabled() {
  // Use your feature flag system
  return getFeatureFlag('react-compiler-enabled');
}
```

### Troubleshooting Adoption 
1. 문제가 있는 컴포넌트를 일시적으로 제외하기 위해 `"use no memo"`를 사용하세요.
2. 자주 발생하는 문제들은 [디버깅 가이드](https://react.dev/learn/react-compiler/debugging)를 확인하세요.
3. ESLint 플러그인이 식별한 React 규칙 위반 사항을 수정하세요.
4. 더 점진적인 도입을 위해 `compilationMode: 'annotation'` 사용을 고려하세요.

