# React Compiler

React Compiler는 빌드 타임에 React 앱을 자동으로 분석해서 메모이제이션을 추가해 주는 도구

`useMemo, useCallback, memo` 등 메모이제이션을 직접 붙여서 불필요한 렌더링을 줄이는 상황이 있었는데, **Compiler**가 대신 수행해줌

-> 개발자가 성능 최적화를 직접 관리하지 않고 개발에만 집중하도록 하기 위해 나옴

```jsx
import { useMemo, useCallback, memo } from "react";

const ExpensiveComponent = memo(function ExpensiveComponent({ data, onClick }) {
  const processedData = useMemo(() => {
    return expensiveProcessing(data);
  }, [data]);

  const handleClick = useCallback(
    (item) => {
      onClick(item.id);
    },
    [onClick]
  );

  return (
    <div>
      {processedData.map((item) => (
        <Item key={item.id} onClick={() => handleClick(item)} />
      ))}
    </div>
  );
});
```

```jsx
function ExpensiveComponent({ data, onClick }) {
  const processedData = expensiveProcessing(data);

  const handleClick = (item) => {
    onClick(item.id);
  };

  return (
    <div>
      {processedData.map((item) => (
        <Item key={item.id} onClick={() => handleClick(item)} />
      ))}
    </div>
  );
}
```

# 점진적으로 적용 및 검증하기

## Babel Override: 특정 경로만 적용하기

특정 directory에만 compiler 적용

```jsx
// babel.config.js
module.exports = {
  plugins: [
    // Global plugins that apply to all files
  ],
  overrides: [
    {
      test: "./src/modern/**/*.{js,jsx,ts,tsx}",
      plugins: ["babel-plugin-react-compiler"],
    },
  ],
};
```

점차 확장하기 + 레거시 코드와 분리해서 검증하기

```jsx
// babel.config.js
module.exports = {
  plugins: [
    // Global plugins
  ],
  overrides: [
    {
      test: [
        "./src/modern/**/*.{js,jsx,ts,tsx}",
        "./src/features/**/*.{js,jsx,ts,tsx}",
      ],
      plugins: ["babel-plugin-react-compiler"],
    },
    {
      test: "./src/legacy/**/*.{js,jsx,ts,tsx}",
      plugins: [
        // Different plugins for legacy code
      ],
    },
  ],
};
```

directory 별로 다른 compiler option을 주는 예시

```jsx
// babel.config.js
module.exports = {
  plugins: [],
  overrides: [
    {
      test: "./src/experimental/**/*.{js,jsx,ts,tsx}",
      plugins: [
        [
          "babel-plugin-react-compiler",
          {
            // options ...
          },
        ],
      ],
    },
    {
      test: "./src/production/**/*.{js,jsx,ts,tsx}",
      plugins: [
        [
          "babel-plugin-react-compiler",
          {
            // options ...
          },
        ],
      ],
    },
  ],
};
```

## use memo로 컴포넌트 단위로 option in 하기

compiler가 적용될 컴포넌트들을 직접 지정하여 검증하는 방식.

컴포넌트 개별 단위로 제어할 수 있다

```jsx
// babel.config.js
module.exports = {
  plugins: [
    [
      "babel-plugin-react-compiler",
      {
        compilationMode: "annotation", // "use memo" 지시문이 붙은 함수만 컴파일
      },
    ],
  ],
};
```

```jsx
function TodoList({ todos }) {
  "use memo"; // 해당 컴포넌트를 컴파일 대상으로 opt in

  const sortedTodos = todos.slice().sort();

  return (
    <ul>
      {sortedTodos.map((todo) => (
        <TodoItem key={todo.id} todo={todo} />
      ))}
    </ul>
  );
}

function useSortedData(data) {
  "use memo"; // hook도 마찬가지

  return data.slice().sort();
}
```

## gating 옵션을 사용

gating은 `React Compiler`가 만든 최적화된 코드를 “항상 쓰는 것”이 아니라 `feature flag`에 따라 선택적으로 쓰도록 만드는 옵션

```jsx
{
  source: string; // Module path to import the feature flag from
  importSpecifierName: string; // Name of the exported function to import
} | null

```

예시

```jsx
// src/utils/feature-flags.js
export function shouldUseCompiler() {
  // your logic here
  return getFeatureFlag("react-compiler-enabled");
}

{
  gating: {
    source: './src/utils/feature-flags',
    importSpecifierName: 'shouldUseCompiler'
  }
}
```

```jsx
// Input
function Button(props) {
  return <button>{props.label}</button>;
}

// Output (simplified)
import { shouldUseCompiler } from "./src/utils/feature-flags";

const Button = shouldUseCompiler()
  ? function Button_optimized(props) {
      /* compiled version */
    }
  : function Button_original(props) {
      /* original version */
    };
```

# TroubleShootings

도입 과정에서 문제 발생 시 대처 방안 제안

- `use no memo` 지시문을 붙여 해당 컴포넌트만 임시로 컴파일 대상에서 제외
- `React Compiler` [debugging guide](https://react.dev/learn/react-compiler/debugging)를 참고해 흔한 이슈를 점검
- ESLint 플러그인이 보고하는 Rules of React 위반을 수정
- 필요하다면 `compilationMode: 'annotation'`으로 전환해 안전한 방식으로 영역을 넓혀가기
