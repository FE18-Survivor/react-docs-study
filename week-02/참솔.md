# Week 02

## [Passing Props to a Component](https://react.dev/learn/passing-props-to-a-component)

- Parent component는 props를 통해 child component에 데이터 전달 가능
- HTML attributes와 달리 JSX로 만들어진 component는 JavaScript 객체, 배열, 함수 등을 전달할 수 있음

### Familiar props

```javascript
<img
  className="avatar"
  src="https://i.imgur.com/1bX5QH6.jpg"
  alt="Lin Lanying"
  width={100}
  height={100}
/>
```

- Props는 JSX tag에 전달하는 정보 (e.g. `<img>` component에 `className`, `src`, `alt`, `width`, `height` 등 전달)
- React가 제공하는 `<img>` 등 기본 tag들에 전달할 수 있는 prop은 ReactDOM에 미리 정의되어 있음 (HTML standard를 준수하는 props)

### Passing props to a component

```javascript
import { getImageUrl } from "./utils.js";

function Avatar({ person, size }) {
  return (
    <img
      className="avatar"
      src={getImageUrl(person)}
      alt={person.name}
      width={size}
      height={size}
    />
  );
}

export default function Profile() {
  return (
    <Avatar
      size={100}
      person={{
        name: "Katsuko Saruhashi",
        imageId: "YfeOqp2",
      }}
    />
  );
}
```

- Custom component에 전달하는 props는 component 함수의 argument로 전달
- Props는 객체로 모아서 전달되므로, **destructuring 문법**을 사용해서 prop 값에 접근 가능

  ```javascript
  function Avatar(props) {
    const person = props.person;
    const size = props.size;
    // ...
  }

  // equals to

  function Avatar({ person, size }) {
    // ...
  }
  ```

- Props를 사용하면 parent와 child components를 독립적으로 생각할 수 있음
  - `Profile`은 `Avatar`가 props를 사용하는 방법을 고려하지 않고 `person`, `size` prop의 값을 변경할 수 있음
  - `Avatar`는 `Profile`이 `Avatar`를 어떻게 사용하는지 고려하지 않고 `person`, `size` prop을 사용한 로직을 변경할 수 있음

### Specifying a default value for a prop

```javascript
function Avatar({ person, size = 100 }) {
  // ...
}

export default function Profile() {
  return (
    <Avatar
      person={{
        name: "Katsuko Saruhashi",
        imageId: "YfeOqp2",
      }}
    />
  );
}
```

- JavaScript destructuring 문법과 동일하게 prop에 `=`로 기본값 설정
- 기본값이 설정된 prop은 값이 전달되지 않을 때에만 사용됨
- 위 코드에서 `Profile`이 `Avatar`에 `size` prop 값을 전달하지 않았으므로, `Avatar` 내부에서 `size`는 기본값(`100`)을 사용

### Forwarding props with the JSX spread syntax

- 같은 이름의 props를 child component에 그대로 전달하는(forwarding props) 경우 코드가 불필요하게 반복됨
  ```javascript
  function Profile({ person, size, isSepia, thickBorder }) {
    return (
      <div className="card">
        <Avatar
          person={person}
          size={size}
          isSepia={isSepia}
          thickBorder={thickBorder}
        />
      </div>
    );
  }
  ```
- JavaScript의 spread syntax를 활용해서 props를 child component로 전달하는 코드를 간결하게(concise) 작성 가능
  ```javascript
  function Profile(props) {
    return (
      <div className="card">
        <Avatar {...props} />
      </div>
    );
  }
  ```
- **단, Spread syntax는 제한적으로 사용해야 한다.**

### Passing JSX as children

```javascript
import Avatar from "./Avatar.js";

function Card({ children }) {
  return <div className="card">{children}</div>;
}

export default function Profile() {
  return (
    <Card>
      <Avatar
        size={100}
        person={{
          name: "Katsuko Saruhashi",
          imageId: "YfeOqp2",
        }}
      />
    </Card>
  );
}
```

- JSX tag에 중첩된 component는 `children` prop으로 전달된다.
- `children` prop을 활용해서 component를 더 유연하게 만들 수 있다. -> `children`에 어떤 component가 들어올 지 신경쓰지 않아도 됨
- `children` prop은 panels, grids 등 visual wrapper에서 사용할 수 있다.

### How props change over time

- Props는 시간이 지남에 따라 바뀔 수 있는 데이터이다.
- 즉, props는 component가 초기화될 때가 아닌 특정 시점에 component가 갖는 data를 나타낸다.
- 하지만 props는 immutable 이므로, **props가 변경되어야 한다면 parent component에 다른 props를 전달해 달라고 요청해야 한다.**
- **Props를 직접 변경하려고 하면 안 된다. 대신, `setState` 같은 state를 사용한다.**

## [Conditional Rendering](https://react.dev/learn/conditional-rendering)

- Component를 특정 조건(condition)에 따라 다르게 보여줘야 할 때가 있다.
- JavaScript의 `if`문, `&&`, `? :` 연산자 등을 사용해서 component를 조건부로 렌더링(conditionally render) 할 수 있다.

### Conditionally returning JSX

- `if`/`else` statement로 조건에 따라 다른 JSX를 반환한다.
  ```javascript
  function Item({ name, isPacked }) {
    if (isPacked) {
      return <li className="item">{name} ✅</li>;
    }
    return <li className="item">{name}</li>;
  }
  ```
  - 조건에 따라 반환되는 두 JSX는 동일(equal)하다.
  - JSX는 실제 DOM node가 아닌 lightweight description 이므로, 각각이 다른 instance가 아님
- 이 때, `null`을 반환하면 아무것도 렌더링하지 않는다.
  ```javascript
  function Item({ name, isPacked }) {
    if (isPacked) {
      return null;
    }
    return <li className="item">{name}</li>;
  }
  ```

### Conditionally including JSX

- JSX 내부 요소를 조건부로 포함시킴으로써, 다른 종류의 JSX를 조건부로 반환할 때 중복되는 코드를 제거할 수 있음
- `? :` operator 사용 (`condition ? <A /> : <B />`)
  ```javascript
  function Item({ name, isPacked }) {
    return <li className="item">{isPacked ? name + " ✅" : name}</li>;
  }
  ```
- `&&` operator 사용 (`condition && <A />`)
  ```javascript
  return (
    <li className="item">
      {name} {isPacked && "✅"}
    </li>
  );
  ```
  - 조건에 따라 렌더링하지 않는 case가 있을 때 활용 가능
  - `? :` operator를 사용할 때 장황해 지는 코드를 단순하게 만들 수 있다.
  - 이 때, **`&&` operator 왼쪽에 숫자를 넣지 않는다.**
    - `&&` 연산자는 왼쪽 피연산자가 truthy 일 때 오른쪽 피연산자를 반환
    - 왼쪽 피연산자가 `0`이면 falsy 값이므로 왼쪽 피연산자를 반환할 것
    - 이 때, React는 `0`을 값으로 인식하여 `0`을 렌더링 하므로 '아무것도 렌더링하지 않을' 상황에 사용할 수 없음
    - 비교 연산자를 사용해서 `boolean` 값으로 반환되게 만들어야 한다.
      - `messageCount` 변수의 값이 0보다 클 때만 렌더링하기
      - `messageCount > 0 && <p>New messages</p>`
- JSX를 변수로 사용
  - 조건에 따라 달라지는 값을 변수에 저장한 뒤 curly braces(`{}`)를 사용해서 JSX에 삽입
    ```javascript
    let itemContent = name;
    if (isPacked) {
      itemContent = name + " ✅";
    }
    return <li className="item">{itemContent}</li>;
    ```
  - 조건식에 JSX를 직접 사용하지 않으므로 확장성이 높다.
