# Passing Props to a Component

## props

컴포넌트 간에 서로 정보를 주고 받을 때, props를 사용한다.

특히 리액트에서 props는 부모 컴포넌트가 자식 컴포넌트에 데이터를 전달할 때 사용하는 속성

```jsx
function Avatar() {
  return (
    <img
      className="avatar"
      src="https://i.imgur.com/1bX5QH6.jpg"
      alt="Lin Lanying"
      width={100}
      height={100}
    />
  );
}
```

JSX에서 HTML 태그를 사용할 때, `className, src, alt, width, height` 등 정해진 속성만 사용할 수 있다.

반면에 React 컴포넌트를 만든다면 props를 자유롭게 정의하고 부모 컴포넌트가 원하는 값을 전달할 수 있다.

## props 전달, 읽기

### 전달

부모 컴포넌트가 자식 컴포넌트를 JSX에서 호출할 때 props를 인자로 전달하고, 전달되는 값들은 자바스크립트 객체 형태로 전달된다.

```jsx
export default function Profile() {
  return (
    <Avatar person={{ name: "Lin Lanying", imageId: "1bX5QH6" }} size={100} />
  );
}
```

### 읽기

```jsx
function Avatar(props) {
  // React 컴포넌트는 매개변수로 props 객체 하나만을 받음
  console.log(props.person);
  console.log(props.size);
}

// 구조 분해 할당으로 바로 선언
function Avatar({ person, size }) {
  console.log(person);
  console.log(size);
}
```

#### prop의 default 값을 설정

```jsx
function Avatar({ person, size = 100 }) {
  // ...
}
```

falsy값 중에 null 또는 0 일 때는 기본값으로 지정 안된다. 조금 유추를 해보자면 undefined 와 null의 차이를 자바스크립트에서 배웠었는데 null이나 0같은 경우에는 undefined와 달리 거의 개발자가 의도적으로 지정해주기 때문에 default값을 적용하지 않을까 싶다.

그래서 가끔 타입을 이용해서 개발을 할 때, 의도치 않게 null일 때는 데이터를 보호하지 못하기 때문에 default값을 설정하지 않고 `nulish ??`를 사용했던 적이 있다.

#### spread

```jsx
function Profile(props) {
  return (
    <div className="card">
      <Avatar {...props} />
    </div>
  );
}
```

스프레드 문법을 이용해서 props를 한번에 모두 전달할 수 있다.

하지만 스프레드 문법을 남용하는 것보다 필요한 데이터만 직접 넘기고, children을 사용해서 좀 더 유연하게 구조를 짜는게 더 좋다.

```jsx
interface ButtonProps
  extends Omit<ButtonHTMLAttributes<HTMLButtonElement>, "className"> {
  children: ReactNode;
  variant: Variant;
  size: Size;
  danger?: boolean;
  className?: string;
}

const BaseButton = ({
  children,
  variant = "solid",
  size = "large",
  className,
  danger,
  ...rest // 어떤 props가 들어올지 예측이 어렵다
}: ButtonProps) => {
  return (
    <button
      {...rest}
      type="button"
      className={cn(
        BASE_BUTTON_BASE_STYLE,
        BASE_BUTTON_STYLE_BY_SIZE[size],
        BASE_BUTTON_STYLE_BY_VARIANT[variant],
        variant.includes("outlined") &&
          size === "medium" &&
          "bg-background-inverse",
        danger && BASE_BUTTON_DANGER_STYLE,
        className
      )}
    >
      {children}
    </button>
  );
};
```

### props의 불변성

props는 불변 객체로 다루어져야 한다.

React에서는 props와 state의 변경을 감지하여 리렌더링을 수행하는데, 이때 불변성을 통해서 변경 여부를 판단한다.

즉, props 객체를 직접 수정하지 않고 새로운 객체로 교체하는 방식으로 변경을 처리해야 한다.

> fiber가 이를 감지하여 Render -> 재조정(이전 prop과 현재 prop 비교, 메모이제이션도 체크) -> commit -> update 과정을 거친다

# Conditional Rendering

## if문을 사용하여 조건부 렌더링

```jsx
function Item({ name, isPacked }) {
  if (isPacked) {
    return <li className="item">{name} ✅</li>;
  }
  return <li className="item">{name}</li>;
}

// null 반환
function Item({ name, isPacked }) {
  if (isPacked) {
    return null;
  }
  return <li className="item">{name}</li>;
}
```

실제로 if문을 사용해서 조건부 렌더링을 할 때, 에러나 로딩처리, 또는 null을 반환하는 경우가 종종 있다.

```jsx
function Modal({ isOpen }) {
  if (!isOpen) {
    return null;
  }
  return ...
}
```

## 삼항 연산자

```jsx
function Item({ name, isPacked }) {
  if (isPacked) {
    return <li className="item">{name} ✅</li>;
  }
  return <li className="item">{name}</li>;
}
```

현재 코드 같은 경우에는 중복되는 부분도 있고 만약 className을 바꿔야 한다면 두 군데 모두 수정 해야하기 때문에 이럴 때는 삼항 연산자를 이용하는게 더 나을 수 있다.

```jsx
function Item({ name, isPacked }) {
  return <li className="item">{isPacked ? name + " ✅" : name}</li>;
}
```

## && 연산자

```jsx
function Item({ name, isPacked }) {
  return (
    <li className="item">
      {name} {isPacked && "✅"}
    </li>
  );
}
```

## let 변수 활용

```jsx
function Item({ name, isPacked }) {
  let itemContent = name;
  if (isPacked) {
    itemContent = name + " ✅";
  }
  return <li className="item">{itemContent}</li>;
}
```

비슷하게 지난 1주차 내용에 있었던 중괄호안에서 함수 호출도 방법이 될 수도 있겠다.

> [week-01 중괄호 사용](https://github.com/FE18-Survivor/react-docs-study/blob/main/week-01/%EC%83%81%EC%9D%B8.md#%EC%A4%91%EA%B4%84%ED%98%B8-%EC%82%AC%EC%9A%A9)

```jsx
function Item({ name, isPacked }) {
  const getItemContent = (name, isPacked) => {
    if (isPacked) {
      return name + " ✅";
    }
  };
  return <li className="item">{getItemContent(name, isPacked)}</li>;
}
```

# 조금 더

## props는 단방향 전달(부모 -> 자식)

![props flow](../images/props-flow.png)
