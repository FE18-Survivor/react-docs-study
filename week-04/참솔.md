# Week 04

## [Updating Objects in State](https://react.dev/learn/updating-objects-in-state)

> **Summary**
>
> - State에 객체를 사용할 때, 객체를 직접 mutate 하지 않고 항상 setter 함수를 통해 새로운 객체(copy)를 만들어서 state를 교체해야 한다.
> - JavaScript의 object spread syntax를 활용해서 이전 state를 복사하고 일부 값만 override 할 수 있다.
> - State 객체가 중첩 객체를 가질 때, 중첩된 객체들도 모두 새로운 객체로 교체해야 한다. 이 때, 'Immer' 라이브러리를 사용하면 mutation syntax를 사용해서 쉽게 객체 복사본을 만들 수 있다.

- Immutable : 값 자체를 변경할 수 없는 값 (unchangeable 또는 read-only)
- Mutable : 변경할 수 있는 값 (e.g JavaScript 객체)
  - Mutation : mutable 값 자체를 변경하는 것
- Numbers, string, booleans 등 "immutable" 값들은 값을 직접 교체해서 re-rendering을 trigger 할 수 있음
- State로 객체를 사용하는 경우, 객체를 mutate 하지 않고 **항상 setter 함수를 통해 새로운 객체로 교체**해야 함 (**read-only 처럼 취급**)

  ```javascript
  const [position, setPosition] = useState({ x: 0, y: 0 });

  // ❌ Mutate an object
  onPointerMove={e => {
    position.x = e.clientX;
    position.y = e.clientY;
  }}

  // ✅ Create a new object
  onPointerMove={e => {
    setPosition({
      x: e.clientX,
      y: e.clientY
    });
  }}
  ```

  - 객체 state를 mutate 해도 어떤 경우에는 잘 동작할 수도 있음
  - 하지만, React가 state 변경 여부를 알 수 없으므로 권장하지 않음
  - 단, local mutation은 가능. State로 사용하는 객체에 대한 mutation만 제한됨

### Copying objects with the spread syntax

- Previous state의 값을 next state에 포함시키고 싶을 때, 객체 spread 문법 활용
  ```javascript
  setPerson({
    ...person, // Copy the old fields
    firstName: e.target.value, // But override this one
  });
  ```
- 여러 개의 `<input>`을 사용할 때 input value들을 객체 state 하나로 관리할 때 활용

  ```javascript
  const [person, setPerson] = useState({
    firstName: "Barbara",
    lastName: "Hepworth",
    email: "bhepworth@sculpture.com",
  });

  function handleInputChange(e) {
    setPerson({
      ...person,
      [e.target.name]: e.target.value,
    });
  }
  ```

  - `<input>`의 `name` 속성에 state 객체의 key를 사용하면 event handler 1개로 여러 `<input>` 값을 처리할 수 있음

### Updating a nested object

- State 객체가 중첩 객체를 갖는 경우,
  ```javascript
  const [person, setPerson] = useState({
    name: "Niki de Saint Phalle",
    artwork: {
      title: "Blue Nana",
      city: "Hamburg",
      image: "https://i.imgur.com/Sd1AgUOm.jpg",
    },
  });
  ```
- 모든 중첩 객체들도 새로운 객체로 교체해야 함
  ```javascript
  setPerson({
    ...person,
    artwork: {
      ...person.artwork,
      city: "Berlin", // Update the nested field
    },
  });
  ```
- JavaScript 객체에서 '중첩(nested)'이라는 표현은 객체의 동작 방식과 맞지 않음

  - 객체가 중첩된 것처럼 보이더라도,
    ```javascript
    let obj = {
      name: "Niki de Saint Phalle",
      artwork: {
        title: "Blue Nana",
        city: "Hamburg",
        image: "https://i.imgur.com/Sd1AgUOm.jpg",
      },
    };
    ```
  - 실제로는 두 개(또는 그 이상의) 개별적인 객체들이 존재하는 것

    ```javascript
    let obj1 = {
      title: "Blue Nana",
      city: "Hamburg",
      image: "https://i.imgur.com/Sd1AgUOm.jpg",
    };

    let obj2 = {
      name: "Niki de Saint Phalle",
      artwork: obj1,
    };
    ```

  - 객체가 중첩된 것이 아니라, 다른 객체를 가리키는 것(pointing)으로 이해해야 함

- 즉, **중첩된 객체는 상위 객체에 포함되지 않는 독립적인 객체**이므로 중첩 객체도 state 변경 시 새로운 객체로 교체해야 함
- 그런데, 객체 중첩이 깊어질수록 중첩 객체들을 새 객체로 일일이 교체하기 어려움
- '[Immer](https://github.com/immerjs/use-immer)' 라이브러리를 사용하면 mutating syntax로 모든 중첩 객체들에 대해 쉽게 copy 가능
  ```javascript
  updatePerson((draft) => {
    draft.artwork.city = "Lagos";
  });
  ```

### Why is mutating state not recommended in React?

1. Debugging
   - state를 mutate 하지 않으면 render 사이에 상태 변화를 추적하기 쉽다.
2. Optimizations
   - React의 optimization strategies(e.g. `useMemo`)는 prop이나 state가 변경되지 않으면 다시 계산하지 않는 것
   - State를 mutate 하지 않으면 React가 state 변경 여부를 빠르게 파악할 수 있다.
3. New Features
   - React는 state를 snapshot처럼 다루기 때문에, 이전 state를 mutate 하면 React의 새로운 기능들을 활용하기 어려워진다.
4. Requirement Changes
   - Application에서 어떤 기능들은 mutate 하지 않았을 때 더 쉽게 구현할 수 있음 (e.g. undo/redo, history of changes 등)
   - State를 mutate 하지 않으면 기존 값을 memory에 유지해서 필요할 때 재사용 할 수 있다.
5. Simpler Implementation
   - React는 mutation에 의존하지 않기 때문에 객체 state를 proxy로 감싸거나 초기화 시점에 다른 작업을 할 필요가 없음
   - 즉, 추가 작업이 필요하지 않기 때문에 state로 크기가 큰 객체를 사용하더라도 성능 문제나 신뢰도 문제가 발생하지 않는다.

---

[Claude 설명](https://claude.ai/share/83b1b3c0-e313-46dc-ba02-c7a94e14e98f)

## [Updating Arrays in State](https://react.dev/learn/updating-arrays-in-state)
