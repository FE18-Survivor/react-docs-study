# Week 04

## [Updating Objects in State](https://react.dev/learn/updating-objects-in-state)

> **Summary**
>
> - State에 객체를 사용할 때, 객체를 직접 mutate 하지 않고 항상 setter 함수를 통해 새로운 객체(copy)를 만들어서 state를 교체해야 한다.
> - JavaScript의 object spread syntax를 활용해서 이전 state를 복사하고 일부 값만 override 할 수 있다.
> - State 객체가 중첩 객체를 가질 때, 중첩된 객체들도 모두 새로운 객체로 교체해야 한다. 이 때, 'Immer' 라이브러리를 사용하면 mutation syntax를 사용해서 쉽게 객체 복사본을 만들 수 있다.

- Immutable : 값 자체를 변경할 수 없는 값 (unchangeable 또는 read-only)
- Mutable : 변경할 수 있는 값 (e.g JavaScript 객체)
  - Mutation : mutable 값 자체를 변경하는 것
- Numbers, string, booleans 등 "immutable" 값들은 값을 직접 교체해서 re-rendering을 trigger 할 수 있음
- State로 객체를 사용하는 경우, 객체를 mutate 하지 않고 **항상 setter 함수를 통해 새로운 객체로 교체**해야 함 (**read-only 처럼 취급**)

  ```javascript
  const [position, setPosition] = useState({ x: 0, y: 0 });

  // ❌ Mutate an object
  onPointerMove={e => {
    position.x = e.clientX;
    position.y = e.clientY;
  }}

  // ✅ Create a new object
  onPointerMove={e => {
    setPosition({
      x: e.clientX,
      y: e.clientY
    });
  }}
  ```

  - 객체 state를 mutate 해도 어떤 경우에는 잘 동작할 수도 있음
  - 하지만, React가 state 변경 여부를 알 수 없으므로 권장하지 않음
  - 단, local mutation은 가능. State로 사용하는 객체에 대한 mutation만 제한됨

### Copying objects with the spread syntax

- Previous state의 값을 next state에 포함시키고 싶을 때, 객체 spread 문법 활용
  ```javascript
  setPerson({
    ...person, // Copy the old fields
    firstName: e.target.value, // But override this one
  });
  ```
- 여러 개의 `<input>`을 사용할 때 input value들을 객체 state 하나로 관리할 때 활용

  ```javascript
  const [person, setPerson] = useState({
    firstName: "Barbara",
    lastName: "Hepworth",
    email: "bhepworth@sculpture.com",
  });

  function handleInputChange(e) {
    setPerson({
      ...person,
      [e.target.name]: e.target.value,
    });
  }
  ```

  - `<input>`의 `name` 속성에 state 객체의 key를 사용하면 event handler 1개로 여러 `<input>` 값을 처리할 수 있음

### Updating a nested object

- State 객체가 중첩 객체를 갖는 경우,
  ```javascript
  const [person, setPerson] = useState({
    name: "Niki de Saint Phalle",
    artwork: {
      title: "Blue Nana",
      city: "Hamburg",
      image: "https://i.imgur.com/Sd1AgUOm.jpg",
    },
  });
  ```
- 모든 중첩 객체들도 새로운 객체로 교체해야 함
  ```javascript
  setPerson({
    ...person,
    artwork: {
      ...person.artwork,
      city: "Berlin", // Update the nested field
    },
  });
  ```
- JavaScript 객체에서 '중첩(nested)'이라는 표현은 객체의 동작 방식과 맞지 않음

  - 객체가 중첩된 것처럼 보이더라도,
    ```javascript
    let obj = {
      name: "Niki de Saint Phalle",
      artwork: {
        title: "Blue Nana",
        city: "Hamburg",
        image: "https://i.imgur.com/Sd1AgUOm.jpg",
      },
    };
    ```
  - 실제로는 두 개(또는 그 이상의) 개별적인 객체들이 존재하는 것

    ```javascript
    let obj1 = {
      title: "Blue Nana",
      city: "Hamburg",
      image: "https://i.imgur.com/Sd1AgUOm.jpg",
    };

    let obj2 = {
      name: "Niki de Saint Phalle",
      artwork: obj1,
    };
    ```

  - 객체가 중첩된 것이 아니라, 다른 객체를 가리키는 것(pointing)으로 이해해야 함

- 즉, **중첩된 객체는 상위 객체에 포함되지 않는 독립적인 객체**이므로 중첩 객체도 state 변경 시 새로운 객체로 교체해야 함
- 그런데, 객체 중첩이 깊어질수록 중첩 객체들을 새 객체로 일일이 교체하기 어려움
- '[Immer](https://github.com/immerjs/use-immer)' 라이브러리를 사용하면 mutating syntax로 모든 중첩 객체들에 대해 쉽게 copy 가능
  ```javascript
  updatePerson((draft) => {
    draft.artwork.city = "Lagos";
  });
  ```

### Why is mutating state not recommended in React?

1. Debugging
   - state를 mutate 하지 않으면 render 사이에 상태 변화를 추적하기 쉽다.
2. Optimizations
   - React의 optimization strategies(e.g. `useMemo`)는 prop이나 state가 변경되지 않으면 다시 계산하지 않는 것
   - State를 mutate 하지 않으면 React가 state 변경 여부를 빠르게 파악할 수 있다.
3. New Features
   - React는 state를 snapshot처럼 다루기 때문에, 이전 state를 mutate 하면 React의 새로운 기능들을 활용하기 어려워진다.
4. Requirement Changes
   - Application에서 어떤 기능들은 mutate 하지 않았을 때 더 쉽게 구현할 수 있음 (e.g. undo/redo, history of changes 등)
   - State를 mutate 하지 않으면 기존 값을 memory에 유지해서 필요할 때 재사용 할 수 있다.
5. Simpler Implementation
   - React는 mutation에 의존하지 않기 때문에 객체 state를 proxy로 감싸거나 초기화 시점에 다른 작업을 할 필요가 없음
   - 즉, 추가 작업이 필요하지 않기 때문에 state로 크기가 큰 객체를 사용하더라도 성능 문제나 신뢰도 문제가 발생하지 않는다.

---

[Claude 설명](https://claude.ai/share/83b1b3c0-e313-46dc-ba02-c7a94e14e98f)

## [Updating Arrays in State](https://react.dev/learn/updating-arrays-in-state)

> **Summary**
>
> - JavaScript array도 object 이므로, array를 state로 사용할 때에도 immutable(read-only) 처럼 다뤄야 한다.
> - Array state를 변경할 때 `push()`, `pop()` 등 mutating methods를 직접 사용하지 않고, `map()`, `filter()` 등 non-mutating methods를 사용해서 새 array로 변환 후 setter 함수로 교체한다.
> - Object item을 갖는 array는 object까지 새 object로 교체해야 한다. 이 때, 'Immer' 라이브러리를 사용하면 mutation syntax를 사용해서 쉽게 객체 복사본을 만들 수 있다.

- 즉, state 변경 시 항상 새 array로 교체해야 함. Array를 직접 변경(mutate)하면 안 된다.
  - e.g. 특정 index의 값을 직접 변경 (`arr[0] = 'bird'`)
- Array를 직접 변경하는 mutating methods는 사용할 수 없다.
  ```javascript
  // ❌
  const handleAddClick = () => {
    artists.push({
      id: nextId++,
      name: name,
    });
  };
  ```
  - `push()`, `pop()`, `unshift()`, `shift()`, `splice()`, `revers()`, `sort()` 등
- 새 array를 직접 만들거나, 원본 array를 변경하지 않고 새로운 array를 만드는 non-mutating methods는 사용할 수 있다.
  - `filter()`, `map()`, `concat()`, `slice()` 등

### Adding to an array

새 array를 만들고 spread syntax로 이전 array items를 복사한 뒤 새 item 추가

```javascript
const handleAddClick = () => {
  // Replace the state with a new array
  setArtists([
    ...artists, // that contains all the old items
    { id: nextId++, name: name }, // and one new item at the end
  ]);
};
```

### Removing from an array

`filter()`로 특정 조건을 만족하지 않는 item 삭제

```javascript
// ✅ Non-mutating
const handleRemoveClick = () => {
  setArtists(artists.filter((a) => a.id !== artist.id));
};
```

### Transforming/Replacing items in an array

`map()`으로 특정 조건을 만족하는 item 변경

```javascript
function handleIncrementClick(index) {
  const nextCounters = counters.map((c, i) => {
    if (i === index) {
      return c + 1; // Increment the clicked counter
    } else {
      return c; // The rest haven't changed
    }
  });
  setCounters(nextCounters);
}
```

### Inserting into an array

Inserting index를 기준으로 `slice()`를 사용해서 array를 나누고, index에 새 item 추가

```javascript
function handleClick() {
  const insertAt = 1; // Could be any index
  const nextArtists = [
    ...artists.slice(0, insertAt), // Items before the insertion point
    { id: nextId++, name: name }, // New item
    ...artists.slice(insertAt), // Items after the insertion point
  ];
  setArtists(nextArtists);
}
```

### Updating objects inside arrays

- 원본 배열의 복사본에는 mutating methods를 사용할 수 있음
  ```javascript
  // ✅
  const handleAddClick = () => {
    const nextArtists = [...artists];
    nextArtists.push({
      id: nextId++,
      name: name,
    });
    setArtists(nextArtists);
  };
  ```
- 이 때, 배열 item이 object라면 복사본 array의 object와 원본 array의 object는 동일함
- 그래서, 복사본 array의 object item을 직접 변경하면(mutate) state를 직접 변경하는 것과 같은 문제 발생
  ```javascript
  // ❌
  function handleToggleMyList(artworkId, nextSeen) {
    const myNextList = [...myList];
    const artwork = myNextList.find((a) => a.id === artworkId);
    artwork.seen = nextSeen;
    setMyList(myNextList);
  }
  ```
- 따라서, array의 object item까지 모두 복사본을 만들어서 새로운 object로 교체해야 함
  ```javascript
  function handleToggleMyList(artworkId, nextSeen) {
    setMyList(
      myList.map((artwork) => {
        if (artwork.id === artworkId) {
          // Create a *new* object with changes
          return { ...artwork, seen: nextSeen };
        } else {
          // No changes
          return artwork;
        }
      })
    );
  }
  ```
- Object와 같이 'Immer' 라이브러리를 사용하면 간결한 문법으로 사용 가능 (원본 객체가 아닌 `draft`를 mutate 하는 것이므로)
  ```javascript
  updateMyTodos((draft) => {
    const artwork = draft.find((a) => a.id === artworkId);
    artwork.seen = nextSeen;
  });
  ```
