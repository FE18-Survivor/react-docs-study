# Updating Objects in State

## 객체 업데이트

### state의 불변성

state의 값이 객체이고, state를 업데이트 할 때는 객체를 직접 변경하지 말고 (readonly), 새로운 객체를 생성해서 교체를 해야한다.

자바스크립트의 원시 타입 데이터는 모두 불변이라는 특징을 가지고 있다.

```jsx
const [x, setX] = useState(0);

setX(5);
```

state `x`를 5로 바꿔줬지만, 이는 0 -> 5 의 개념이 아니고, 0 대신 새로운 5를 만들어서 state `x`를 업데이트 하는 것이다.

state 의 값이 객체라고 가정해보자.

자바스크립트의 참조 타입 데이터는 기본적으로 가변값이다. 조금 더 정확히는 객체의 참조 자체는 불변이지만 내부 프로퍼티가 참조하는 값을 변경(mutation)할 수 있다는 의미에서 가변이다.

```jsx
const [position, setPosition] = useState({ x: 0, y: 0 });

position.x = 5;
```

원시 타입에서의 예시처럼 참조 타입의 예시도 `position.x`를 바꿔주면서 값을 변경했으니 리렌더링이 될 것이라고 오해하기 쉽다.

이렇게 내부 프로퍼티만 변경하면 state 객체 자체의 참조(identity)는 유지되기 때문에, React는 **변경이 없다**고 판단하고 리렌더링하지 않는다.

React에서는 객체 state도 원시 타입과 동일하게 *새로운 값으로 교체하는 방식*으로 업데이트해야 한다.

원시 타입에서는 **값을 바꾼 것이 아닌 새로운 값을 대입해준 것**이기 때문에 업데이트가 업데이트가 반영된 것이고, 객체 타입에서도 불변성 규칙을 지키기 위해서 내부 프로퍼티의 참조값을 바꾸는 것이 아닌 새로운 객체로 교체해줘야 업데이트가 반영된다.

흐름을 다시 정리하자면

- React의 State는 불변성 규칙을 따르고, 새로운 값으로 교체해줘야 변경을 감지하여 업데이트 가능하다.
- 원시 타입에서의 값 변경은 사실 새로운 값으로의 교체이다.
- 참조 타입도 똑같이 새로운 객체로 교체해줘야한다.

### local mutation

아래 코드와 같이 local mutation은 반영된다!

```jsx
function exam() {
  const [position, setPosition] = useState({ x: 0, y: 0 }); // 1
  const nextPosition = {}; // 2
  nextPosition.x = e.clientX;
  nextPosition.y = e.clientY;
  setPosition(nextPosition);
}
```

state의 객체 `{x:0, y:0}` 과 `nextPosition`은 다른 객체이기 때문에 업데이트가 반영이 되고, 다음 렌더링에서도 state가 바뀌어 있으며, nextPosition은 새로 만들어진 객체이기 때문에 계속해서 업데이트가 된다.

## 객체 복사: spread 문법

위에서 정리한 객체를 업데이트하기 위해서는 아래와 같이 새로운 객체를 만들어서 교체해줘야한다.

```jsx
export default function Form() {
  const [person, setPerson] = useState({
    firstName: "Barbara",
    lastName: "Hepworth",
    email: "bhepworth@sculpture.com",
  });

  function handleFirstNameChange(e) {
    setPerson({
      firstName: e.target.value,
      lastName: person.lastName,
      email: person.email,
    });
  }
}
```

하지만 하나의 프로퍼티만 변경 되고 있기 때문에 spread 문법을 활용하여 객체를 복사하고, 새로운 객체를 만드는 기법이 있다.

```jsx
export default function Form() {
  const [person, setPerson] = useState({
    firstName: "Barbara",
    lastName: "Hepworth",
    email: "bhepworth@sculpture.com",
  });

  function handleFirstNameChange(e) {
    setPerson({
      ...person,
      firstName: e.target.value,
    });
  }
}
```

주의할 점으로 spread 문법은 얕은 복사이기 때문에 만약 state가 중첩 객체일 때(프로퍼티의 key가 다른 객체를 가르킬 때)의 상황을 고려해줘야한다.

```jsx
const [person, setPerson] = useState({
  name: "Niki de Saint Phalle",
  artwork: {
    title: "Blue Nana",
    city: "Hamburg",
    image: "https://i.imgur.com/Sd1AgUOm.jpg",
  },
});

setPerson({
  ...person,
  artwork: {
    ...person.artwork,
    city: "Busan",
  },
});
```

## Immer

첩된 객체나 복잡한 구조를 다룰 때 유용한 해결책으로 Immer 라이브러리가 있다고 한다. Immer는 객체를 직접 수정하는 것처럼 작성하지만, 실제 내부에서는 불변성을 유지한 새 객체를 생성해주는 라이브러리다.

```jsx
updatePerson((draft) => {
  draft.artwork.city = "Seoul";
});
```

# Updating Arrays in State

배열도 사실 객체이기 때문에 객체와 동일한 방법으로 업데이트를 해줘야 한다.

이 챕터에서는 그런 업데이트 방법들, 어떤 메서드들이 원본 배열을 변경하지 않으며 새로운 배열로 만들어서 업데이트할 수 있는지 설명하는 챕터이다.

## 배열의 주요 메서드들

| 원본 변경          | 새 배열           |
| ------------------ | ----------------- |
| push, unshift      | concat, [...arr]  |
| pop, shift, splice | filter, slice     |
| splice, arr[i]=    | map               |
| reverse, sort      | 먼저 복사 후 변경 |

## 예시

### 항목 추가

push 대신 spread 문법 혹은 concat 사용하기

```jsx
setArtists([...artists, { id: nextId++, name: name }]);
```

### 항목 제거

filter 사용하기

```jsx
setArtists(artists.filter((a) => a.id !== artist.id));
```

### 배열 변환

```jsx
setShapes(
  shapes.map((shape) =>
    shape.type === "square" ? shape : { ...shape, y: shape.y + 50 }
  )
);
```

### 배열 복사 후 내부 객체

복사한 배열이어도 내부 겍체를 수정하는 것은 원본에 영향을 미친다. 코드 상으로는 배열의 내부에 있는 것이지만 실제로 메모리에서는 배열 밖에 저장되어있고 배열의 인덱스가 참조하기 때문이다.

```jsx
const myNextList = [...myList];
const artwork = myNextList.find((a) => a.id === artworkId);
artwork.seen = nextSeen; // 여기서 새로운 객체를 만들어줘야함
setMyList(myNextList);

// 수정
setMyList(
  myList.map((artwork) =>
    artwork.id === artworkId ? { ...artwork, seen: nextSeen } : artwork
  )
);
```

이렇게 예시들을 들어놨지만 핵심은 원본 배열을 변경하지말고 새로운 배열을 반환하는 메서드, 혹은 복사 후 그 배열을 변환하는 방식을 강조하고있다.
