# Week 04

> 11.25 (화)

## Updating Objects in State

React에서 object의 값을 변경하려면 불변 값(immutable)처럼 여기며 변경해야 합니다.

또한 Javascript의 object는 read-only state를 갖게 됩니다.

따라서 JS에서 object의 값을 주는것과 다르게 할당합니다.

```javascript
import { useState } from "react";

export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0,
  });
  return (
    <div
      onPointerMove={(e) => {
        position.x = e.clientX;
        position.y = e.clientY;
      }}
      style={{
        position: "relative",
        width: "100vw",
        height: "100vh",
      }}
    >
      <div
        style={{
          position: "absolute",
          backgroundColor: "red",
          borderRadius: "50%",
          transform: `translate(${position.x}px, ${position.y}px)`,
          left: -10,
          top: -10,
          width: 20,
          height: 20,
        }}
      />
    </div>
  );
}
```

```javascript
❌
onPointerMove={e => {
  position.x = e.clientX;
  position.y = e.clientY;
}}

✅
onPointerMove={e => {
  setPosition({
    x: e.clientX,
    y: e.clientY
  });
}}
```

setter 함수를 통해서

1. `position`을 새로운 객체로 변경해야함
2. 해당 컴포넌트를 re-render 해야함

두 가지를 react가 알 수 있게 됩니다.

### Local mutation is fine

```javascript
const nextPosition = {};
nextPosition.x = e.clientX;
nextPosition.y = e.clientY;
setPosition(nextPosition);
```

새로운 객체를 만들어서 그 객체에 이벤트로 발생한 값을 할당하고, setter 함수를 이용하면, `position`이 변경됩니다.
즉, 기존에 이미 존재하는 객체의 값을 바꾸는 것만 문제가 되고, 새로운 값으로 "대체" 하는것은 문제가 되지 않습니다.

위의 코드는 setter 함수를 사용한 코드와 동일합니다.

### Copying objects with the spread syntax

객체의 일부 속성만 값이 변경될땐 spread 구문을 활용합니다.

```javascript
const [person, setPerson] = useState({
  firstName: "Barbara",
  lastName: "Hepworth",
  email: "bhepworth@sculpture.com",
});

function handleFirstNameChange(e) {
  setPerson({
    ...person,
    firstName: e.target.value,
  });
}
```

spread 구문은 "얕은 복사"만 가능합니다. 객체가 중첩되어 있다면, 복사를 한번 더 해야 합니다.

#### 핸들러 이벤트로 요소 하나씩만 변경 할 경우

```javascript
function handleChange(e) {
  setPerson({
    ...person,
    [e.target.name]: e.target.value,
  });
}
```

여러 input을 만들어서 각각의 event가 있는 경우, target.name과 target.value 속성을 활용하여 하나의 핸들러로 여러 input의 이벤트를 다룰 수 있습니다.

### Updating a nested object

객체의 속성이 중첩되어 있다면, spread 구문을 한번만 사용해선 복사가 되지 않습니다. 중첩된 속성(객체)을 따로 복사한 후, 기존 객체를 복사해야 합니다.

```javascript
const [person, setPerson] = useState({
  name: "Niki de Saint Phalle",
  artwork: {
    title: "Blue Nana",
    city: "Hamburg",
    image: "https://i.imgur.com/Sd1AgUOm.jpg",
  },
});
```

여기서 city만 변경한다고 예를 들겠습니다.

```javascript
// case 1
const nextArtwork = { ...person.artwork, city: "New Delhi" };
const nextPerson = { ...person, artwork: nextArtwork };
setPerson(nextPerson);

// case 2
setPerson({
  ...person,
  artwork: {
    ...person.artwork,
    city: "New Delhi",
  },
});
```

#### Objects are not really nested

```javascript
let obj = {
  name: "Niki de Saint Phalle",
  artwork: {
    title: "Blue Nana",
    city: "Hamburg",
    image: "https://i.imgur.com/Sd1AgUOm.jpg",
  },
};

// 위와 동일
let obj1 = {
  title: "Blue Nana",
  city: "Hamburg",
  image: "https://i.imgur.com/Sd1AgUOm.jpg",
};

let obj2 = {
  name: "Niki de Saint Phalle",
  artwork: obj1,
};
```

name과 artwork로 객체를 나눌 수 있습니다.
코드만 보면 obj2 안에 obj1의 "값"이 있는것처럼 보이지만, obj2에서 artwork를 수정하면 obj1도 같이 수정됩니다.

그 이유는 obj2의 artwork가 obj1의 값을 가리키고 있기(pointing) 때문입니다.

### Write concise update logic with Immer

Immer는 라이브러리로, 값을 변경하는 구문을 쉽게 작성하게 하고 복사본을 관리합니다.

일반적인 mutation과 달리, 이전 state를 덮어쓰지 않습니다.

#### How does Immer work?

Immer는 `Proxy`라는 초안(draft)객체를 제공하여 당신이 무엇을 하는지를 기록합니다. 이를 통해 쉽게 변경할 수 있게 해줍니다.
Immer가 draft의 어디가 변경되었는지 파악하고, 수정된 부분을 포함한 새 객체를 만듭니다.

- 사용법

1. 라이브러리를 설치합니다.
   `npm install use-immer`
2. `useState` 대신 `useImmer`를 사용합니다.

```javascript
import { useImmer } from "use-immer";
...
const [person, updatePerson] = useImmer({
    name: 'Niki de Saint Phalle',
    artwork: {
      title: 'Blue Nana',
      city: 'Hamburg',
      image: 'https://i.imgur.com/Sd1AgUOm.jpg',
    }
  });
...
```

한 컴포넌트 내부에서 `useState`와 `useImmer`를 혼합하여 사용해도 문제가 되지 않습니다.

### Why is mutating state not recommended in React?

- Debugging : `console.log`를 사용해서 debugging을 할때, state가 변경되지 않음으로 렌더링 간의 차이를 구분할 수 있습니다.
- Optimizations : react의 일반적인 최적화 전략은 이전 props나 state가 변경될 값과 동일하다면 해당 작업은 skip하는것 입니다. 따라서 mutating하지 않으면 매우 빠르게 값이 변경되었는지 확인 할 수 있습니다.
- New Features : react의 신 기능들은 상태를 `snapshot`을 기준으로 만들어집니다. state를 mutating 한다면 해당 기능을 사용하는데 어려워질 것입니다.
- Requirement Changes : Undo/Redo 같은 기능이나, 사용자에게 reset을 제공하는 기능 등은 state가 변경되지 않아야 훨씬 쉽습니다. 이전 상태들의 복사본이 memory에 있기 때문에 재사용하기에도 쉽기 때문입니다.
- Simpler Implementation : React가 mutate에 의존하지 않기 때문에 객체에 특별한 일을 하지 않아도 됩니다. 따라서 아무리 큰 객체이더라도 추가 작업 없이 state로 관리할 수 있습니다.

<br />

## Updating Arrays in State

React에서 Array는 state로 관리할때 immutable하게 처리되어야 합니다.

|           | avoid                           | prefer                         |
| --------- | ------------------------------- | ------------------------------ |
| adding    | push, unshift                   | concat, [...arr] spread syntax |
| removing  | pop, shift, splice              | filter, slice                  |
| replacing | splice, arr[i] = ... assignment | map                            |
| sorting   | reverse, sort                   | copy the array first           |

- [Adding Example](https://react.dev/learn/updating-arrays-in-state#adding-to-an-array)
- [Removing Example](https://react.dev/learn/updating-arrays-in-state#removing-from-an-array)
- [Replacing Example](https://react.dev/learn/updating-arrays-in-state#replacing-items-in-an-array)
- [Sorting Example](https://react.dev/learn/updating-arrays-in-state#making-other-changes-to-an-array)
