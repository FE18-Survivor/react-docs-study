# Week 08
## Lifecycle of Reactive Effects

> Effect와는 컴포넌트와 다른 생명주기를 가집니다. 
- Component : 마운트, 업데이트, 언마운트
- Effect : 동기화 시작 / 동기화 중지

props와 state에 따라 사이클이 여러번 발생될 수 있습니다.
리액트는 린터 규칙을 제공해서 Effects가 정확한 디펜던시를 갖고 있는지 체크합니다.
이를 통해 Effects가 props와 state의 최신상태와 동기화 됩니다.



### 동기화가 왜 되어야 하는지, 어떻게 되는지

chatroom을 예로 들자면 사용자가 ChartRoom에 들어오면 컴포넌트는 마운트 됩니다. 그 상태에서 roomId만 변경된다면 컴포넌트는 여전히 마운트 되어있고 거기서 roomId에 따라 연결되는 카테고리만 바뀌게 됩니다. 이에 맞춰 Effect가 prop(roomId)에 맞추어 동기화가 진행되어야 합니다.

roomId가 바뀌면 Effect는 기존 roomId와의 연결을 끊고 새 roomId와 연결을 진행합니다.

따라서 Effects의 한 사이클에서의 start/stop에만 집중하면 문제없이 몇번이고 동기화가 잘 이루어질 것입니다.


[How React verifies that your Effect can re-synchronize](https://react.dev/learn/lifecycle-of-reactive-effects#how-react-verifies-that-your-effect-can-re-synchronize)

예제코드를 테스트 해보면 개발환경에서 리액트가 이펙트를 바로 재동기화 하고 있습니다. 이는 클린업 코드가 잘 동작하는지 확인하기 위해서 입니다.

실제로 Effects가 재 동기화 되는이유는 어떠한 데이터가 변경되어서 입니다. 예제에선 roomId가 변경되면 재 동기화 되는것을 확인할 수 있습니다.


### List of dependencies
리액트는 의존성 배열을 보고 Effects의 재동기화 필요 유무를 확인합니다.
컴포넌트가 re-render되면 리액트는 의존성 배열을 확인합니다. 배열에 값이 있고 이전 렌더링값과 배열의 값이 달라져 있다면 리액트는 Effect를 재동기화 할것입니다.
- Effect가 읽는 변수 중에 re-render시에도 변하지 않는 값이 있다면 의존성 배열에 넣을 필요가 없습니다.
- 만약 state 변수 였다면 dependencies에 추가되어야 합니다.
- dependencies가 비어있다면 컴포넌트가 마운트 될때에만 커넥트 되고, 컴포넌트가 언마운트될때에 디스커넥트 됩니다. 마운트 상태에서 추가로 재 동기화 되지 않습니다.
- props나 state뿐만 아니라 렌더링 중에 계산되는 변수도 reacitve이기 때문에 의존성 배열에 추가될 수 있습니다.


### Separate synchronization process 
- 각각의 Effects는 하나의 독립적인 동기화 프로세스를 나타내야 합니다.
- Effect 로직을 지웠을때 다른 로직에 영향이 없다면 Effect가 서로 다른것을 동기화 했다는 것으로 나누는것이 좋은 로직입니다.
- Effects를 나눌때엔 코드를 깔끔하게 하기 위함이 아니라, 같은 프로세스인지 아닌지를 기준으로 나누는것이 좋습니다.

### Don`t want to re-synchronize

의존성 배열에 있던 변수들을 상수로 바꾸고 dependencies를 공란으로 두면 재 동기화가 발생하지 않습니다.
linter가 reactive한 값들을 확인하기 때문에 Effect가 읽던 변수를 reactive하지 않게 바꾸는것이 먼저 진행되어야 합니다.

- Effects는 reactive한 코드블록 입니다.
- dependencies는 선택할 수 없고, Effects에 있는 reactive value는 전부 dependencies에 있어야 합니다.
- Effect를 수정할때 에러나 무한루프에 빠지지 않도록 아래를 확인해보세요.
    - 독립적인 동기화 프로세스인지 확인하세요
    - props와 state의 최신값을 가져오고 싶지만 재동기화는 하고 싶지 않을때엔, reactive와 non-reactive를 분리해보세요
    - dependencies에 object나 함수가 들어가는건 피하세요.

<br />

## Separating Events from Effects

### Event와 Effect의 차이점

- Event : 수동으로 trigger 됩니다. (사용자의 click 등 event 발생)
- Effect : 자동으로 재 동기화 됩니다.

둘의 큰 차이는 **reactive** 입니다.

- event 내부 로직은 reactive하지 않습니다. 사용자가 interaction을 하지 않으면 다시 실행되지 않습니다. reactive value를 읽을때 그 변화에 반응하지 않습니다.
- effect 내부 로직은 reactive 합니다. dependencies를 특정하고, 변수값이 바뀌면 리액트는 Effects의 로직도 재 실행 시킵니다.


### [Effects에서 non-reactvie logic 추출하기](https://react.dev/learn/separating-events-from-effects#extracting-non-reactive-logic-out-of-effects)

처음 예제에선 Effect의 dependencies에 roomId와 theme 두개가 들어가서, theme이 변경되면 Effect도 재 동기화 되는 문제가 있었습니다. 이를 분리하고 같이 실행하기 위해 `useEffectEvent`를 활용할 수 있습니다.

Effect 로직의 일부이지만 Event handler 처럼 동작하게 됩니다.

```javascript
function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(() => {
    showNotification('Connected!', theme);
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      onConnected();
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ✅ All dependencies declared
  // ...
```

### [Reading latest props and state with Effect Events](https://react.dev/learn/separating-events-from-effects#reading-latest-props-and-state-with-effect-events)
- Effect Event를 통해 latest props와 state를 받을 수 있고, Effect 로직에서 활용할 수 있습니다.
- 대신 props와 state가 변경되어도 Effect의 dependecy에 추가되어 있지 않으므로 Effect는 재 동기화 되지 않습니다.

### Effect Event의 한계
- Effect 안에서만 호출 될 수 있습니다.
- 다른 hook이나 컴포넌트로 값을 넘겨줄 수 없습니다.