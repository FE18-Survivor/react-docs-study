# Week 08

## [Lifecycle of Reactive Effects](https://react.dev/learn/lifecycle-of-reactive-effects)

**Summary**

- Effect의 lifecycle은 component와 독립적으로 생각해야 함
  - Component 관점에서 lifecycle : mount - update - unmount
  - Effect 관점에서 lifecycle : start/stop synchronization
  - 즉, Effect의 lifecycle 에서는 **어떻게 동기화를 시작하고 중단할 것인지만 고려**
    - Effect body에서 동기화 시작
    - Cleanup function에서 동기화 중단
  - Effect에서 동기화의 시작/중단을 잘 구현했다면 development 환경(strict mode)에서 Effect가 두 번 실행되어도 문제 없음
- Reactive values와 Effect re-synchronization
  - Reactive values : Component re-render에 의해 변경될 수 있는 값
    - e.g. props, state, component body에서 선언된 값
    - ## Mutable values는 reactive values가 아님 (component re-render를 trigger 하지 않음)
  - Effect 내부에서 사용되는(의존하는) 모든 reactive values는 dependencies list에 명시해야 함
  - Dependencies list에 명시된 값이 re-render 사이에 변경되면(`Object.is` 비교) Effect는 re-synchronize 됨
  - 어떤 값이 reactive values가 아니라면, 선언을 component 외부 또는 Effect 내부로 옮길 수 있음
- Effect는 독립된 하나의 synchronization process를 나타내야 함
  - Effect 내부에 unrelated logic을 포함시키지 않음 (e.g. logging)
  - 독립된 여러 process들은 여러 개의 Effect로 분리
- Effect에서 의존하는 reactive values를 dependencies list에 명시하지 않으면 linter가 error를 표시해 줌
  - 단, stable values(`useState`의 `set` 함수, `useRef`의 ref object 등)는 제외 가능
  - `// eslint-disable-next-line react-hooks/exhaustive-deps` 등으로 linter를 무시하지 말 것

### The lifecycle of an Effect

- React component의 lifecycle
  1. **Mount** : component가 screen에 추가됨
  2. **Update** : user interaction 등에 의해 새 props 또는 state를 받음
  3. **Unmount** : Screen에서 제거됨
- 이 lifecycle은 Effect를 이해하는 데에는 적절하지 않음
- Effect는 각 component의 lifecycle과 독립적으로 생각해야 함
  - Effect는 external system을 props와 state에 동기화하는 방법
  - React component가 mount 될 때 Effect 동기화 시작
  - React component가 unmount 될 때 Effect 동기화 중지
  - React component가 update 될 때 Effect 동기화 시작/중지가 여러 번 필요할 수 있음

### Why synchronization may need to happen more than once

- Props 또는 state 값을 사용해서 extenral system과 동기화 하는 경우, (e.g. chat room connection)
- Props 또는 state가 변경되면 이전 동기화를 해제하고 새 props 및 state로 다시 동기화해야 함
- React component 에서는 props나 state가 변경될 때마다 re-render(update) lifecycle을 거침
- Effect body 에서는 동기화를 시작하고 cleanup function 에서는 동기화를 중지함. 이것을 순서대로 실행하면 re-synchronize 하는 것
- 즉, **React component가 다른 props 또는 state로 re-render 될 때마다, Effect는 re-synchronize 됨**

### How React re-synchronizes your Effect

- Synchronizing을 중지하기 위해 React는 Effect가 이전 render에서 반환했던 cleanup function을 실행
- 이후, 현재 render 에서는 Effect body를 실행해서 새로운 synchronization을 시작
- Chat room 예시
  ```javascript
  function ChatRoom({ roomId }) {
    useEffect(() => {
      const connection = createConnection(serverUrl, roomId);
      connection.connect();
      return () => connection.disconnect();
    });
  }
  ```
  - Component가 mount 될 때 `roomId`가 `general` 이라면 최초 동기화는 `general` room 으로 연결
  - 이후 사용자가 UI에서 다른 chat room을 클릭하면 `roomId`가 변경되어 component가 re-render
  - 이 때, 이전에 연결했던 `general` room의 연결을 해제하고(cleanup function) 새로운 `roomId`로 다시 연결(Effect body)

### Thinking from the Effect's perspective

- Component 관점에서의 lifecycle은 Effect를 "render 이후" 또는 "unmount 이전" 등 **특정 시점에 실행되는 "callback" 또는 "lifecycle events"**로 생각했음
- 이러한 접근 대신, **한 번에 하나의 start/stop cycle이 발생하는 것에 집중**하는 것이 좋음 (focus on a single start/stop cycle at a time)
- Component의 mounting, updating, unmounting에 관계 없이 **"어떻게 동기화를 시작하고 중단할 것인지"만 생각하면 됨**
- 이렇게 하면 rendering logic을 작성할 때 component가 mounting 또는 updating 되었는지 등을 신경쓰지 않고 screen에 무엇을 보여줄 것인지만 집중할 수 있음

### How React verifies that your Effect can re-synchronize

- React는 development mode에서 동기화를 연결 즉시 해제하여 Effect가 re-synchronize 할 수 있는지 검증 (strict mode)
  - Re-synchronize 할 수 있다면, Effect가 cleanup을 잘 실행한다는 것
- Effect가 re-synchronize 해야 하는 이유는 사용하고 있는 data가 변경될 수 있기 때문임

### How React knowsw that it needs to re-synchronize the Effect

- Dependencies list에 Effect가 의존하는 값을 명시함으로써, React가 언제 re-synchronize 해야 하는지 알 수 있음
- React는 component가 re-render 될 때마다 dependencies array에 명시된 값들을 이전 render와 비교하고, 이전과 다른 값이 있다면 re-synchronize가 필요하다고 판단
  - 값을 비교할 때는 `Object.is` 사용
- Component가 re-render 되었지만 dependencies array에 명시된 값입 변경되지 않았다면 re-synchronize 하지 않음 (이전 연결 상태를 유지)

### Each Effect represents a separate synchronization process

- Effect와 관련 없는 logic을 Effect와 동시에 실행해야 한다는 이유만으로 추가하지 말 것 (e.g. logging)
- 나중에 다른 dependency가 추가되는 경우, Effect가 re-synchronize 될 때 의도하지 않게 logic이 실행될 수 있음
- 이 경우, 다른 Effect로 분리해서 작성

  ```javascript
  function ChatRoom({ roomId }) {
    // 여기서 logging logic은 `roomId` 하나에만 의존해야 함
    useEffect(() => {
      logVisit(roomId);
    }, [roomId]);

    // 이 Effect는 connection을 수행하므로 logging logic을 함께 작성하면 안 됨
    // 나중에 다른 dependency가 추가되면 logging logic이 의도치 않은 시점에도 실행될 수 있음
    useEffect(() => {
      const connection = createConnection(serverUrl, roomId);
      // ...
    }, [roomId]);
    // ...
  }
  ```

- 즉, **각각의 Effect는 분리되어 독립적인 synchronization process를 나타내야 함**
- 반대로, 서로 연관된 logic을 다른 Effect로 분리하면 코드는 깔끔해 보일 수 있지만 유지보수하기는 더 어려워 진다.
- **Effect에 포함시킬 코드를 분리할 때는 code 가독성이 아닌 동일한 process를 수행하는지를 기준**으로 해야 함

### Effects "react" to reactive values

- Effect에서 사용하는 값들 중 **re-render 중에 변경될 수 있는 값**들만 dependency로 설정
- Props, states, component 내부에서 정의된 값 등 rendering 중간에 계산되는 값들 등이 reactive values에 해당
- Reactive values가 변경될 때마다 Effect는 re-synchronize 됨

### What an Effect with empty dependencies means

- Effect code가 reactive values를 사용하지 않는다면, dependencies list는 빈 배열(`[]`)이 될 수 있음
- Empty dependencies는 **Effect가 component mount 시점에 한 번만 connect 되고, unmount 시점에 한 번만 disconnect** 되는 것을 의미
- 하지만, Effect의 관점에서 본다면 mounting과 unmounting을 고려하지 않고 **synchronizing의 시작/종료만 고려하면 됨**

### All variables declared in the component body are reactive

- Props 및 state 외에도 이들을 사용해서 계산하는 값도 reactive values에 해당
- Props 또는 state가 변경되면 component가 re-render 되므로 계산된 값(calculated values)도 변경될 것
- 따라서, **Effect에서 사용되는 값들 중 component body에서 선언된 변수들은 모두 dependencies list에 명시해야 함**
- 예시
  ```javascript
  function ChatRoom({ roomId, selectedServerUrl }) {
    // roomId is reactive
    const settings = useContext(SettingsContext); // settings is reactive
    const serverUrl = selectedServerUrl ?? settings.defaultServerUrl; // serverUrl is reactive
    useEffect(() => {
      const connection = createConnection(serverUrl, roomId); // Your Effect reads roomId and serverUrl
      connection.connect();
      return () => {
        connection.disconnect();
      };
    }, [roomId, serverUrl]); // So it needs to re-synchronize when either of them changes!
    // ...
  }
  ```
  - 위 코드에서 `serverUrl`은 prop이나 state가 아니지만 rendering 도중 계산되는 값이므로 dependencies list에 포함
- 즉, **모든 reactive values는 re-render 중에 변경될 수 있으므로 Effect의 dependencies list에 포함됨**
- **Global variables를 포함한 mutable values는 reactive values가 아님**
  - Mutable values는 React의 rendering data flow 외부에서 변경될 수 있음
  - 즉, mutable values가 변경되어도 re-render를 trigger 하지 않음
  - 따라서, mutable values를 dependencies list에 명시하더라도 React는 이 값이 변경되었을 때 re-synchronize 하지 않음
  - 또, mutable data를 rendering 도중에 사용하는 것은 순수성 원칙(purity of rendering)을 위반하는 것임
  - External mutable value는 `useSyncExternalStore` hook을 사용해서 synchronization 해야 함
  - 예시 : `location.pathname`, `ref.current` 등

### React verifies that you specified every reactive value as a dependency

- React linter를 사용하면 Effect에서 사용된 모든 reactive value가 dependency에 정의되어 있는지 확인하고 error를 표시해 줌
- 어떤 경우에는, React가 component 내부에 선언된 값이지만 변경되지 않을 것임을 알고 있음
  - `useState`가 반환하는 `set` 함수
  - `useRef`가 반환하는 ref object
- **이러한 stable values는 reactive 하지 않으므로, list에서 제외해도 됨**

### What to do when you don't want to re-synchronize

- Re-render에 의해 변경될 수 없는 값이라면, 이 값들은 reactive values가 아니라고 증명(prove)할 수 있음
- 이런 값들은 component 바깥의 top-level 또는 Effect 내부로 옮길 수 있음
- Dependencies에는 Effect에서 read 하는 모든 reactive values를 포함해야 하고, linter가 이것을 강제하는 것
- 가끔 이 규칙이 infinite loops를 만들거나 re-synchronize를 너무 자주 발생하게 만들 수 있는데, **이런 문제를 linter를 무시하는 방법으로 고치면 안된다.**
- 대신 시도할 수 있는 방법들
  - **Effect가 독립적인 synchronization process를 나타내는지 확인하기**
    - Effect가 아무 것도 synchronize 하지 않는다면 불필요하게 Effect를 사용하는 것
    - Synchronize 하는 독립적인 값들을 각각 다른 Effect로 분리할 것
  - **Reacting 또는 re-synchronizing 하지 않고 props나 state의 최근 값을 얻고 싶다면, Effect를 분리하기**
    - Effect를 reactive part와 non-reactive part로 분리
  - **Objects나 함수들을 dependencies로 사용하지 않기**
    - Rendering 중에 objects나 functions를 생성하고 Effect에서 사용한다면, re-render 마다 다른 값이 되어 re-synchronize를 매번 실행하게 됨

## [Separating Events from Effects](https://react.dev/learn/separating-events-from-effects)

**Summary**

- Event handlers는 사용자 interaction에 의해 실행되는 non-reactive logic을 실행한다.
- Effects는 props, state 등 rendering flow에 참여하여 re-render에 의해 변경될 수 있는 값들을 사용하는 reactive logic을 실행한다.
- `useEffectEvent` hook을 사용해서 Effects 내부에서 non-reactive logic을 Effect Event로 분리할 수 있다.
- `dependencies` list의 linter error는 강제로 끄지 않는다.

### Choosing between event handlers and Effects

- Event handler들은 동일한 interaction을 다시 수행해야 재실행 됨
- Effects는 props, state 등 의존하는 값이 last render와 다를 때 재실행(re-synchronize) 됨
- Event handler와 Effect 중 어떤 곳에서 코드를 실행시킬지 결정할 때는 **"이 코드가 왜 실행되어야 하는지"**를 생각해 본다.
  - 사용자에 의해 특정 interaction이 발생했을 떄 실행해야 한다면 event handler를 사용한다.
  - 사용자 interaction과 무관하게 실행되어야 한다면 Effect를 사용한다.

### Reactive values and reactive logic

- Event handlers는 항상 수동적으로(manually) trigger 됨
- Effects는 synchronize 되어야 할 때 자동으로(automatically) 실행됨
- **Reactive values**
  - Props, state, component 내부에 선언된 변수 등 rendering flow에 사용되는(participate in) 값들
  - Reactive values는 re-render에 의해 값이 변경될 수 있음
- 이 때, event handlers와 Effects는 값 변경에 다르게 반응함
  - **Logic inside event handlers is not reactive**
    - 사용자가 동일한 특정 interaction을 다시 수행하기 전까지 다시 실행되지 않음
    - 즉, 값의 변경에 반응(reacting)하지 않음
  - **Logic inside Effects is reactive**
    - Re-render에 의해 Effect가 의존하는 값이 변경되면 Effect logic이 재실행됨
    - 즉, 값의 변경에 반응해서 동작

### Extracting non-reactive logic out of Effects

- Reactive logic을 non-reactive logic과 함께 실행하는 방법
- Chat room에 연결된 후 현재 theme에 맞는 UI로 notification을 보여주는 예시
  ```javascript
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on("connected", () => {
      showNotification("Connected!", theme);
    });
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId, theme]);
  ```
  - `roomId`가 변경되면 connection을 재설정 해야하므로 정상 동작함
  - `theme`이 변경될 때는 connection이 재설정 될 필요가 없지만, `theme`이 `dependencies` list에 포함되어 있으므로 Effect가 재실행되는 문제가 있음
  - 즉, 위 코드는 **Effect에 non-reactive logic이 포함되어 문제가 발생**
- **Non-reactive logic(event handler)를 Effect로부터 분리**하기 위해 `useEffectEvent` hook 사용 (**Effect event**)
  ```javascript
  const onConnected = useEffectEvent(() => {
    showNotification("Connected!", theme);
  });
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on("connected", onConnected);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
  ```
  - `useEffectEvent`가 반환하는 함수는 Effetc logic의 일부이지만, event handler처럼 동작
  - 이 함수는 내부에서 props와 state를 항상 latest values를 사용
  - 이 때, **effect events는 non-reactive logic 이므로 `dependencies` list에 포함되지 않음**
  - Effect event와 event handlers의 차이
    - Event handlers는 user interaction에 의해 실행됨
    - Effect events는 Effect 로부터 실행됨
- Event events는 `dependencies` list linter를 무시하고 싶을 때 대안으로 활용할 수 있음
  ```javascript
  function Page({ url }) {
    const { items } = useContext(ShoppingCartContext);
    const numberOfItems = items.length;

    const onVisit = useEffectEvent(visitedUrl => {
      logVisit(visitedUrl, numberOfItems);
    });

    useEffect(() => {
      onVisit(url);
    }, [url]); // ✅ All dependencies declared
    // ...
  }
  ```
  - `url` prop이 변경될 때마다 log를 실행해야 하지만, `numberOfItems`는 변경되어도 Effect를 실행시키면 안 됨
  - 이 경우, `url`만 `dependencies` list에 포함시키고, log를 남기는 logic을 Effect event(`onVisit`)로 분리
  - `numberOfItems`가 `dependencies` list에 포함되지 않았으므로, 이 값이 변경되어도 Effect는 재실행되지 않음
  - 동시에, `numberOfItems`를 사용하는 logic을 Effect 내부에서 사용 
- **Effect Events를 사용하여 `dependencies` list linter를 무시하지 않는 것을 권장**
  - `dependencies` list에 포함되어야 하는 새 reactive value를 사용할 때, list에 명시하지 않는 실수를 할 수 있음
  - 또는, 더 이상 의존하지 않는 reactive value를 list에서 제거하지 않는 실수를 할 수 있음
  - `useEffectEvent`가 항상 올바른 해결책이 아닐 수 있음. Effect 내부에서 non-reactive logic을 분리하고 싶을 때만 사용
- Effect events는 사용하는 방법에 따라 제한사항이 있음
  - **Effects 내부에서만 호출해야 함**
  - **다른 components 또는 hooks에 전달하지 않아야 함**
    - 항상 `useEffect` 근처에서 선언하고 사용