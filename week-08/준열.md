# <a href="https://react.dev/learn/lifecycle-of-reactive-effects">Lifecycle of Reactive Effects</a>

> Effects는 Components와 다른 life cycle를 가지고 있다. <br />
> 동기화를 시작하거나 동기화를 중지하는 두 가지 뿐이다.

### The lifecycle of an Effect

- Effects의 동기화 과정을 Components 관점에서는 **마운트시 한 번**, **언마운트시 한 번** 진행될 것 처럼 보이지만

- 실제로는 **동기화를 여러번 시작하고 중지**할 수 도 있다.

- 이러한 이유를 다음 챕터를 통해 알아보자. 🤔

### Why synchronization may need to happen more than once 

- 간단한 예시를 통해 동기화를 여러번 시작할수도 있는 **이유**를 알아보자.

- **채팅방 A** 와 **채팅방 B**가 있을 때, 사용자가 채팅방 A를 클릭하게 된다면 어떤일이 벌어질까?

- **A 라는 아이디**를 가진 채팅방 **컴포넌트가 마운트** 된 후 **useEffect**를 통해 **외부 서비스**가 **연결** 될 것이다.

- 그렇다면 **사용자**가 **채팅방 B**를 클릭하게 되면 **아이디 값**이 **바뀌면서** **컴포넌트가 리렌더링** 될 것이다.

- 여기서 문제는 **useEffect를 통해 연결된 서비스**는 **여전히** **채팅방 A**를 **가리키고 있다**는 것이다.

- **이러한 문제**를 **해결**하기 위해 **동기화를 여러번 진행**해야하는 이유가 완성된다.

- **useEffect**를 통해 **외부서비스를 연결**하는 동작이 **한 번 더 실행**되어야 비로소 **올바른 결과를 표출**하기 때문이다.

### How React re-synchronizes your Effect

- 그렇다면 **React**가 **Effect**를 **재동기화**하는 방법을 알아보자.

- 처음에 사용자가 채팅방 A를 선택해서 들어가면, 컴포넌트가 렌더링되고 Effect가 실행되면서 채팅방 A와 동기화가 시작된다.
​

- 이후 사용자가 채팅방 B를 선택해서 아이디 값이 A에서 B로 바뀌면, React는 먼저 이전 effect가 반환한 cleanup 함수를 호출해서 채팅방 A와의 동기화를 중지한다.
​
- 그리고 이번 렌더 기준으로 effect를 다시 실행해서, 바뀐 아이디값에 맞춰 채팅방 B와 새로 동기화를 시작한다.
​

- 사용자가 채팅방 B에서 또 다른 방으로 이동해도, 항상 `이전 채팅방과의 동기화 중지 → 새로운 채팅방과의 동기화 시작`이 반복된다.
​

- 마지막으로 채팅방 UI를 닫거나 다른 화면으로 이동해서 컴포넌트가 언마운트되면, React가 cleanup을 한 번 더 호출해서 마지막으로 접속해 있던 채팅방과의 동기화도 중지한다.

### Thinking from the Effect’s perspective

- 동기화 과정을 Effect의 관점에서 바라본다면 어떨까?

- 컴포넌트 관점에서는 아이디가 채팅방 A로 설정된 채 마운트되었다가, 채팅방 B로 업데이트되고, 다시 채팅방 C로 업데이트된 뒤 언마운트되는 흐름으로 보인다.
​

- 같은 상황을 Effect 관점에서 보면

  - 채팅방 A에 연결된 Effect(끊어질 때까지)

  - 채팅방 B에 연결된 Effect(끊어질 때까지)

  - 채팅방 C에 연결된 Effect(끊어질 때까지)라는 겹치지 않는 시간 구간들의 연속으로 이해할 수 있다.
​
- 따라서 Effect를 **렌더링 후 한 번 실행되는 콜백 함수**가 아니라,

- 한 번의 동기화 시작 → 나중의 동기화 중지로 이루어진 하나의 **사이클 단위 프로세스**로 보는 것이 좋다.
​

- 이때 중요한 것은 “지금이 마운트냐 업데이트냐”가 아니라, 
  - 동기화를 어떻게 시작할지
  - 언제·어떻게 중지할지 명확히 정의하는 것이다. 

- 이렇게 해두면 React가 필요할 때마다 Effect를 여러 번 시작하고 중지해 준다.

### How React verifies that your Effect can re-synchronize 

- 그렇다면 React는 Effect의 **동기화 과정**을 **어떻게 점검**할까?

- **개발 환경(Strict Mode)** 에서 React는 컴포넌트를 일부러 한 번 더 마운트했다가 언마운트해서, **Effect의 동기화**가 **정상적**으로 **시작/중지** 되는지를 테스트한다.
​

- 이때 같은 채팅방에 두 번 연결, 해제되는 로그가 찍히는 것은 **dev-only stress test**일 뿐이고, 프로덕션에서는 한 번만 실행된다.
​

- 실제 앱에서 Effect가 **재동기화**되는 **주된 이유**는 **아이디 같은 반응형 값**이 **변경**될 때이며, 이런 상황에서도 **cleanup → 재실행** 흐름이 올바르게 동작하는지 **React가 개발 단계**에서 **미리 검증해 두는 과정**이라 생각하면 된다.
​
### How React knows that it needs to re-synchronize the Effect 

- 이어서 React는 Effect가 재동기화해야 한다는 것을 어떻게 인식할까?

- 아래 예시코드를 통해 알아보자.

```javascript
function ChatRoom({ roomId }) {
  // roomId prop은 시간이 지남에 따라 변경될 수 있다.
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // 이 Effect는 roomId를 읽음
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]); // 이 Effect가 roomId에 "의존"한다고 React에 알려줌
  // ...
}
```

- roomId는 시간에 따라 바뀔 수 있는 prop이고, Effect 안에서 이 값을 읽고 있다.
​

- 그래서 의존성 배열에 roomId를 넣어 두면, React는 **이 Effect는 roomId에 의존한다**라고 인식한다.
​
- **컴포넌트**가 **다시 렌더링**될 때마다 **React**는 **이전 렌더링의 의존성 배열**과 **지금 배열을 각 인덱스별**로 **비교**한다.
​
- 이전이 ["A"], 지금이 ["B"]이면 **값이 다르므로** **기존 Effect를 cleanup → 새 Effect 실행**해서 **재동기화**한다.
​
이전도 ["A"], 지금도 ["A"]이면 **값이 같으므로** **기존 연결을 유지**하고 **Effect**를 **재실행하지 않는다.**

### Each Effect represents a separate synchronization process

- 각 Effect는 **무엇을 동기화할지** 기준으로 나뉜 독립된 동기화 프로세스 하나를 표현해야 한다.
​
## Effects “react” to reactive values 

- 반응형 값이면서, 해당 Effect 안에서 읽고 있다면 → 반드시 의존성 배열에 포함해야 한다.

- 반응형 값이라도 그 Effect 내부에서 전혀 사용하지 않는다면 → 그 Effect의 의존성 배열에는 넣지 않는다.

- 그렇다면, 반응형 값이면서 Effect가 읽고 있는 경우에도 의존성 배열에 포함하고 싶지 않은 경우가 존재한다면 어떻게 해야할까?

### What an Effect with empty dependencies means

- 빈 의존성 배열에 대해 알아보자.

- 의존성 배열이 비어 있다면 컴포넌트 관점에서는 **마운트될 때 한 번 동기화 시작, 언마운트될 때 한 번 cleanup 하는 Effect**를 뜻한다.

- 이때 Effect 안에서 사용하는 값들은 모두 반응형이 아닌 상수여야 하고, 그래서 []만으로도 **모든 의존성을 선언했다**고 간주할 수 있다.

- 나중에 roomId나 serverUrl처럼 반응형 값이 추가로 필요해지면, Effect 코드는 그대로 두고 **Effect가 읽는 반응형 값들을 의존성 배열에 추가**해서 다시 동기화되도록 만들면 된다.

### All variables declared in the component body are reactive

- 두 가지 경우로 생각해볼 수 있을 것 같다.

- 컴포넌트 내부에 선언 됐지만 **렌더링에 따라 값이 변하지 않는 값**
  - ex ) 고정 상수, 환경에 따라 절대 안바뀌는 값 등..
  - 이런 것들은 컴포넌트 외부나 Effect 내부로 옮겨서 반응형이 아니라는 것을 나타내는게 좋다.

- 컴포넌트 내부에 선언됐고, **렌더링에 따라 달라질 수 있는 값 = 반응형 값**
  - ex ) 예: props, state, context, 그들로부터 계산된 serverUrl 같은 변수들
  - 이런 것들 중에서 Effect가 실제로 읽는 것들만 의존성 배열에서 관리하면 된다.
​
### React verifies that you specified every reactive value as a dependency 

- Effect에서 읽는 모든 반응형 값들은 의존성 배열에 반드시 포함되어야 하며,linter는 이를 자동으로 검사한다.

### What to do when you don’t want to re-synchronize 

- 마지막으로, 재동기화를 하지 않으려면 어떻게 해야할지 알아보자.

- 앞서 말한, `반응형 값이면서 Effect가 읽고 있는 경우에도 의존성 배열에 포함하고 싶지 않은 경우가 존재한다면 어떻게 해야할까?` 질문에 대한 답변을 할 수 있을 것 같다.

- 바로 **종속성은 선택할 수 없다.**

- Effect는 **읽는 모든 반응형 값**을 의존성으로 반드시 포함해야 하고, **linter**가 이를 강제한다.
​
- 만약 재동기화하고 싶지 않다면, 그 값을 애초에 반응형이 아니게(컴포넌트 외부 상수나 Effect 내부 상수로) 옮기거나
​
- Effect와 이벤트/로직을 분리해서 **정말로 반응해야 하는 값들만 읽는 Effect** 가 되도록 설계를 바꿔야 한다.
​
- 반대로, 렌더링 때마다 새로 만들어지는 객체/함수를 의존성에 넣어서 매번 재동기화가 발생하는 상황이라면
  
  - **eslint-ignore**로 **무시**하는 것이 아니라 구조를 바꿔 불필요한 의존성을 없애는 것이 정석적인 해결책이다.
​
# <a href="https://react.dev/learn/separating-events-from-effects">Separating Events from Effects</a>

